#!/usr/bin/env node
var nt=Object.defineProperty;var T=(r,t)=>nt(r,"name",{value:t,configurable:!0});import Y,{Router as B}from"express";import it from"cors";import dt from"better-sqlite3";import H from"path";import J from"fs";import z from"multer";import W from"decimal.js";import _ from"jsonwebtoken";import ct from"dotenv";import ut from"http";import{Server as lt}from"socket.io";const K=H.resolve(),Z=H.resolve(K,"./database.sqlite"),mt=H.resolve(K,"./schema.sql");let x;try{const r=J.existsSync(Z);if(x=new dt(Z),!r){console.log("Creating new database with schema...");const t=J.readFileSync(mt,"utf8");x.exec(t)}}catch(r){throw console.error("Database initialization error:",r),r}var d=x;const q=B();q.get("/",(r,t)=>{const a=d.prepare("SELECT * FROM Item").all().map(o=>({...o,isActive:!!o.isActive,variablePrice:!!o.variablePrice,printLocations:JSON.parse(o.printLocations||"[]")}));t.json(a)}),q.post("/",(r,t)=>{const{name:e,quantity:s,unit:a,isActive:o,category:n,supplier:i,printLocations:c,variablePrice:u,recipe:l,price:p}=r.body,h=d.prepare(`INSERT INTO Item (name, quantity, unit, isActive, category, supplier, printLocations, variablePrice, recipe, price)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(e,s,a,o?1:0,n,i,JSON.stringify(c),u?1:0,l,p);t.json({id:h.lastInsertRowid}),console.log(`Item ADDED by USER at ${new Date().toLocaleString("es-MX")}`)}),q.put("/:id",(r,t)=>{const{id:e}=r.params,{name:s,quantity:a,unit:o,isActive:n,category:i,supplier:c,printLocations:u,variablePrice:l,recipe:p,price:m}=r.body;d.prepare(`UPDATE Item
     SET name = ?, quantity = ?, unit = ?, isActive = ?, category = ?, supplier = ?, printLocations = ?, variablePrice = ?, recipe = ?, price = ?
     WHERE id = ?`).run(s,a,o,n?1:0,i,c,JSON.stringify(u),l?1:0,p,m,e).changes>0?(t.json({message:"Item updated successfully"}),console.log(`Item UPDATED by USER at ${new Date().toLocaleString("es-MX")}`)):t.status(404).json({error:"Item not found"})}),q.delete("/:id",(r,t)=>{const{id:e}=r.params;d.prepare("DELETE FROM Item WHERE id = ?").run(e).changes>0?(t.json({message:"Item deleted successfully"}),console.log(`Item DELETED by USER at ${new Date().toLocaleString("es-MX")}`)):t.status(404).json({error:"Item not found"})});const L=B();L.get("/",(r,t)=>{const a=d.prepare("SELECT * FROM Agent").all().map(o=>({...o,isActive:!!o.isActive}));t.json(a)}),L.get("/names",(r,t)=>{const s=d.prepare("SELECT id, name, lastName FROM Agent").all();t.json(s)}),L.post("/",(r,t)=>{const{name:e,lastName:s,image:a,address:o,phone:n,rfc:i,email:c,pin:u,role:l,isActive:p}=r.body,h=d.prepare(`INSERT INTO Agent (name, lastName, image, address, phone, rfc, email, pin, role, isActive)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(e,s,a,o,n,i??null,c,u,l,p?1:0);t.json({id:h.lastInsertRowid}),console.log(`Agent ADDED by USER at ${new Date().toLocaleString("es-MX")}`)}),L.put("/:id",(r,t)=>{const{id:e}=r.params,{name:s,lastName:a,image:o,address:n,phone:i,rfc:c,email:u,pin:l,role:p,isActive:m}=r.body;d.prepare(`UPDATE Agent
     SET name = ?, lastName = ?, image = ?, address = ?, phone = ?, rfc = ?, email = ?, pin = ?, role = ?, isActive = ?
     WHERE id = ?`).run(s,a,o,n,i,c,u,l,p,m?1:0,e).changes>0?(t.json({message:"Agent updated successfully"}),console.log(`Agent UPDATED by USER at ${new Date().toLocaleString("es-MX")}`)):t.status(404).json({error:"Agent not found"})}),L.delete("/:id",(r,t)=>{const{id:e}=r.params;d.prepare("DELETE FROM Agent WHERE id = ?").run(e).changes>0?(t.json({message:"Agent deleted successfully"}),console.log(`Agent DELETED by USER at ${new Date().toLocaleString("es-MX")}`)):t.status(404).json({error:"Agent not found"})});const ht=z.diskStorage({destination:T((r,t,e)=>{const s="storage/images";J.existsSync(s)||J.mkdirSync(s,{recursive:!0}),e(null,s)},"destination"),filename:T((r,t,e)=>{const s=`agent-${Date.now()}-${Math.round(Math.random()*1e9)}${H.extname(t.originalname)}`;e(null,s)},"filename")}),pt=z({storage:ht,limits:{fileSize:5*1024*1024},fileFilter:T((r,t,e)=>{const s=/jpeg|jpg|png|webp/,a=s.test(H.extname(t.originalname).toLowerCase()),o=s.test(t.mimetype);a&&o?e(null,!0):e(new Error("Invalid file type. Only JPEG, PNG and WEBP allowed."))},"fileFilter")});L.post("/upload-image",pt.single("image"),(r,t)=>{try{if(!r.file)return t.status(400).json({error:"No file uploaded"});const e=`http://localhost:3000/images/${r.file.filename}`;t.json({imageUrl:e}),console.log(`Image uploaded by USER at ${new Date().toLocaleString("es-MX")}`)}catch(e){console.error("Upload error:",e),t.status(500).json({error:"Failed to upload image"})}});class w{static{T(this,"MenuItem")}static tableName="MenuItem";constructor({id:t,name:e,quantity:s,unit:a,isActive:o,categoryId:n,printLocations:i,variablePrice:c,price:u}){this.id=t||null,this.name=e,this.quantity=s,this.unit=a,this.isActive=!!o,this.categoryId=n,this.printLocations=Array.isArray(i)?i:JSON.parse(i||"[]"),this.variablePrice=c||!1,this.price=u}static getAll(){return d.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new w(s))}static getById(t){const s=d.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new w(s):null}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=d.prepare(`INSERT INTO ${w.tableName} (name, quantity, unit, isActive, categoryId, printLocations, variablePrice, price)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`).run(this.name,this.quantity,this.unit,this.isActive?1:0,this.categoryId,JSON.stringify(this.printLocations),this.variablePrice?1:0,this.price);return this.id=e.lastInsertRowid,this.id}#e(){return d.prepare(`UPDATE ${w.tableName}
            SET name = ?, quantity = ?, unit = ?, isActive = ?, categoryId = ?, printLocations = ?, variablePrice = ?, price = ?
            WHERE id = ?`).run(this.name,this.quantity,this.unit,this.isActive?1:0,this.categoryId,JSON.stringify(this.printLocations),this.variablePrice?1:0,this.price,this.id).changes}delete(){if(!this.id)throw new Error("Cannot delete an unsaved MenuItem.");return d.prepare(`DELETE FROM ${w.tableName} WHERE id = ?`).run(this.id).changes>0}}class g{static{T(this,"Ingredient")}static tableName="Ingredients";constructor({id:t,menuItemId:e,inventoryProductId:s,quantityUsed:a}){this.id=t||null,this.menuItemId=e,this.inventoryProductId=s,this.quantityUsed=a}static getAll(){return d.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new g(s))}static getByMenuItemId(t){return d.prepare(`SELECT * FROM ${this.tableName} WHERE menuItemId = ?`).all(t).map(a=>new g(a))}static deleteByMenuItemId(t){return d.prepare(`DELETE FROM ${this.tableName} WHERE menuItemId = ?`).run(t).changes>0}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=d.prepare(`INSERT INTO ${g.tableName} (menuItemId, inventoryProductId, quantityUsed)
            VALUES (?, ?, ?)`).run(this.menuItemId,this.inventoryProductId,this.quantityUsed);return this.id=e.lastInsertRowid,this.id}#e(){return d.prepare(`UPDATE ${g.tableName}
            SET menuItemId = ?, inventoryProductId = ?, quantityUsed = ?
            WHERE id = ?`).run(this.menuItemId,this.inventoryProductId,this.quantityUsed,this.id).changes>0}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Ingredient.");return d.prepare(`DELETE FROM ${g.tableName} WHERE id = ?`).run(this.id).changes>0}}class I{static{T(this,"StockItem")}static tableName="StockItem";constructor({id:t,name:e,stock:s,minStock:a,unit:o,isActive:n,categoryId:i,supplierId:c,cost:u}){this.id=t||null,this.name=e,this.minStock=a,this.stock=s,this.unit=o,this.isActive=!!n,this.categoryId=i,this.supplierId=c,this.cost=u}static getAll(){return d.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new I(s))}static getById(t){const s=d.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new I(s):null}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=d.prepare(`INSERT INTO ${I.tableName} (name, stock, minStock, unit, isActive, categoryId, supplierId, cost)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`).run(this.name,this.stock,this.minStock,this.unit,this.isActive?1:0,this.categoryId,this.supplierId,this.cost);return this.id=e.lastInsertRowid,this.id}#e(){return d.prepare(`UPDATE ${I.tableName}
            SET name = ?, stock = ?, minStock = ?, unit = ?, isActive = ?, categoryId = ?, supplierId = ?, cost = ?
            WHERE id = ?`).run(this.name,this.stock,this.minStock,this.unit,this.isActive?1:0,this.categoryId,this.supplierId,this.cost,this.id).changes>0}delete(){if(!this.id)throw new Error("Cannot delete an unsaved StockItem.");return d.prepare(`DELETE FROM ${I.tableName} WHERE id = ?`).run(this.id).changes>0}}const S=B();S.get("/menu-items",(r,t)=>{try{const e=w.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch menu items. "+e.message})}}),S.get("/menu-items/:id",(r,t)=>{try{const{id:e}=r.params,s=w.getById(Number(e));s?t.json(s):t.status(404).json({error:"MenuItem not found."})}catch(e){t.status(500).json({error:"Failed to fetch menu item. "+e.message})}}),S.get("/menu-items-with-ingredients",(r,t)=>{try{const s=w.getAll().map(a=>{const n=g.getByMenuItemId(a.id).map(i=>{const c=I.getById(i.inventoryProductId);return{...i,stockItem:c}});return{...a,ingredients:n}});t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch menu items with ingredients. "+e.message})}}),S.get("/menu-items/:id/ingredients",(r,t)=>{try{const{id:e}=r.params,s=w.getById(Number(e));if(s){const o=g.getByMenuItemId(s.id).map(n=>{const i=I.getById(n.inventoryProductId);return{...n,stockItem:i}});t.json({...s,ingredients:o})}else t.status(404).json({error:"MenuItem not found."})}catch(e){t.status(500).json({error:"Failed to fetch menu item. "+e.message})}}),S.post("/menu-items",(r,t)=>{try{const e=new w(r.body),s=e.save();r.body.ingredients.forEach(i=>{new g({menuItemId:s,inventoryProductId:i.inventoryProductId,quantityUsed:i.quantityUsed}).save()});const n=g.getByMenuItemId(e.id).map(i=>{const c=I.getById(i.inventoryProductId);return{...i,stockItem:c}});t.status(201).json({...e,ingredients:n})}catch(e){t.status(500).json({error:"Failed to create menu item. "+e.message})}}),S.put("/menu-items/:id",(r,t)=>{const e=r.params.id,{name:s,quantity:a,unit:o,isActive:n,categoryId:i,printLocations:c,variablePrice:u,price:l,ingredients:p}=r.body;let m=w.getById(e);if(!m)return t.status(404).json({error:"Menu item not found"});m.name=s,m.quantity=a,m.unit=o,m.isActive=n,m.categoryId=i,m.printLocations=c,m.variablePrice=u,m.price=l,m.save(),g.deleteByMenuItemId(e),p.forEach(j=>{new g({menuItemId:e,inventoryProductId:j.inventoryProductId,quantityUsed:j.quantityUsed}).save()});const M=g.getByMenuItemId(e).map(j=>{const P=I.getById(j.inventoryProductId);return{...j,stockItem:P}});t.json({...m,ingredients:M})}),S.delete("/menu-items/:id",(r,t)=>{try{const{id:e}=r.params,s=w.getById(Number(e));s?(s.delete(),t.json({message:"MenuItem deleted successfully."})):t.status(404).json({error:"MenuItem not found."})}catch(e){t.status(500).json({error:"Failed to delete menu item. "+e.message})}}),S.get("/ingredients",(r,t)=>{try{const e=g.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch ingredients. "+e.message})}}),S.get("/ingredients/menu-item/:menuItemId",(r,t)=>{try{const{menuItemId:e}=r.params,s=g.getByMenuItemId(Number(e));t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch ingredients. "+e.message})}}),S.post("/ingredients",(r,t)=>{try{const e=new g(r.body);if(!w.getById(e.menuItemId))return t.status(404).json({error:"MenuItem not found."});if(!I.getById(e.inventoryProductId))return t.status(404).json({error:"Inventory product not found."});const o=e.save();t.status(201).json({id:o})}catch(e){t.status(500).json({error:"Failed to create ingredient. "+e.message})}}),S.put("/ingredients/:id",(r,t)=>{try{const{id:e}=r.params,s=g.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"Ingredient updated successfully."})):t.status(404).json({error:"Ingredient not found."})}catch(e){t.status(500).json({error:"Failed to update ingredient. "+e.message})}}),S.delete("/ingredients/:id",(r,t)=>{try{const{id:e}=r.params,s=g.getById(Number(e));s?(s.delete(),t.json({message:"Ingredient deleted successfully."})):t.status(404).json({error:"Ingredient not found."})}catch(e){t.status(500).json({error:"Failed to delete ingredient. "+e.message})}}),S.get("/stock-items",(r,t)=>{try{const e=I.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch stock items. "+e.message})}}),S.get("/stock-items/:id",(r,t)=>{try{const{id:e}=r.params,s=I.getById(Number(e));s?t.json(s):t.status(404).json({error:"StockItem not found."})}catch(e){t.status(500).json({error:"Failed to fetch stock item. "+e.message})}}),S.post("/stock-items",(r,t)=>{try{const s=new I(r.body).save();t.status(201).json({id:s})}catch(e){t.status(500).json({error:"Failed to create stock item. "+e.message})}}),S.put("/stock-items/:id",(r,t)=>{try{const{id:e}=r.params,s=I.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"StockItem updated successfully."})):t.status(404).json({error:"StockItem not found."})}catch(e){t.status(500).json({error:"Failed to update stock item. "+e.message})}}),S.delete("/stock-items/:id",(r,t)=>{try{const{id:e}=r.params,s=I.getById(Number(e));s?(s.delete(),t.json({message:"StockItem deleted successfully."})):t.status(404).json({error:"StockItem not found."})}catch(e){t.status(500).json({error:"Failed to delete stock item. "+e.message})}});class E{static{T(this,"RecurrentDate")}static tableName="RecurrentDate";constructor({id:t,promoId:e,dayOfWeek:s,startTime:a,endTime:o}){this.id=t||null,this.promoId=e,this.dayOfWeek=s,this.startTime=a,this.endTime=o}static getAll(){return d.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new E(s))}static getById(t){const s=d.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new E(s):null}static getByPromoId(t){return d.prepare(`SELECT * FROM ${this.tableName} WHERE promoId = ?`).all(t).map(a=>new E(a))}isNowWithinRule(){const t=new Date,e=t.getDay(),a=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"][e];if(this.dayOfWeek!==a)return!1;const[o,n]=this.startTime.split(":").map(Number),[i,c]=this.endTime.split(":").map(Number),u=new Date(t);u.setHours(o,n,0,0);const l=new Date(t);return l.setHours(i,c,0,0),l<=u&&l.setDate(l.getDate()+1),t>=u&&t<=l}isTimeWithinRule(t){const e=t.getDay(),a=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"][e];if(this.dayOfWeek!==a)return!1;const[o,n]=this.startTime.split(":").map(Number),[i,c]=this.endTime.split(":").map(Number),u=new Date(t);u.setHours(o,n,0,0);const l=new Date(t);return l.setHours(i,c,0,0),l<=u&&l.setDate(l.getDate()+1),t>=u&&t<=l}save(){if(this.id)return d.prepare(`UPDATE ${E.tableName}
                SET promoId = ?, dayOfWeek = ?, startTime = ?, endTime = ?
                WHERE id = ?`).run(this.promoId,this.dayOfWeek,this.startTime,this.endTime,this.id).changes>0;{const e=d.prepare(`INSERT INTO ${E.tableName} (promoId, dayOfWeek, startTime, endTime)
                VALUES (?, ?, ?, ?)`).run(this.promoId,this.dayOfWeek,this.startTime,this.endTime);return this.id=e.lastInsertRowid,this.id}}delete(){if(!this.id)throw new Error("Cannot delete an unsaved RecurrentDate.");return d.prepare(`DELETE FROM ${E.tableName} WHERE id = ?`).run(this.id).changes>0}}class b{static{T(this,"Promo")}static tableName="Promo";constructor({id:t,menuItemId:e,startDate:s,endDate:a,type:o,discount:n,buy_quantity:i,pay_quantity:c,percentage:u,always:l,isActive:p,name:m}){this.id=t||null,this.menuItemId=e,this.startDate=s,this.endDate=a,this.type=o,this.discount=n||null,this.buy_quantity=i||null,this.pay_quantity=c||null,this.percentage=u||null,this.always=!!l||!1,this.isActive=!!p,this.name=m}static getAll(){return d.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new b(s))}static getById(t){const s=d.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new b(s):null}static getActiveByMenuItemId(t){return d.prepare(`SELECT * FROM ${this.tableName} WHERE menuItemId = ? AND isActive = 1`).all(t).map(n=>new b(n)).filter(n=>n.isCurrentlyActive())}static getByMenuItemId(t){const s=d.prepare(`SELECT * FROM ${this.tableName} WHERE menuItemId = ?`).get(t);return s?new b(s):null}isCurrentlyActive(){const t=new Date;return this.always?!0:this.startDate&&t<new Date(this.startDate)||this.endDate&&t>new Date(this.endDate)?!1:this.getRecurrenceRules().some(s=>s.isNowWithinRule())}isValidAtTimestamp(t){const e=new Date(t);return this.always?!0:this.startDate&&e<new Date(this.startDate)||this.endDate&&e>new Date(this.endDate)?!1:this.getRecurrenceRules().some(a=>a.isTimeWithinRule(e))}calculateDiscount(t,e,s){let a=0;if(this.type==="percentage_discount")a=e*(this.percentage/100);else if(this.type==="buy_x_get_y"){const o=this.buy_quantity-this.pay_quantity;a=Math.floor(t/this.buy_quantity)*o*s}else this.type==="price_discount"&&(a=this.discount*t);return a}getRecurrenceRules(){if(!this.id)throw new Error("Cannot fetch recurrence rules for an unsaved Promo.");return E.getByPromoId(this.id)}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=d.prepare(`INSERT INTO ${b.tableName} (menuItemId, startDate, endDate, type, discount, buy_quantity, pay_quantity, percentage, always, isActive, name)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(this.menuItemId,this.startDate,this.endDate,this.type,this.discount,this.buy_quantity,this.pay_quantity,this.percentage,this.always?1:0,this.isActive?1:0,this.name);return this.id=e.lastInsertRowid,this.id}#e(){return d.prepare(`UPDATE ${b.tableName}
            SET menuItemId = ?, startDate = ?, endDate = ?, type = ?, discount = ?, buy_quantity = ?, pay_quantity = ?, percentage = ?, always = ?, isActive = ?, name = ?
            WHERE id = ?`).run(this.menuItemId,this.startDate,this.endDate,this.type,this.discount,this.buy_quantity,this.pay_quantity,this.percentage,this.always?1:0,this.isActive?1:0,this.name,this.id).changes>0}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Promo.");return E.getByPromoId(this.id).forEach(a=>a.delete()),d.prepare(`DELETE FROM ${b.tableName} WHERE id = ?`).run(this.id).changes>0}}class f{static{T(this,"OrderItem")}static tableName="OrderItem";constructor({id:t,menuItemId:e,orderId:s,promoId:a,quantity:o,subtotal:n,discountApplied:i,total:c,promoName:u,comments:l,quantityHistory:p="[]",appliedPromos:m="[]",createdAt:h,updatedAt:M,readyQuantity:j}){this.id=t||null,this.menuItemId=e,this.orderId=s,this.promoId=a||null,this.quantity=o,this.subtotal=n,this.discountApplied=i||0,this.total=c||n-this.discountApplied,this.promoName=u||null,this.comments=l||null,this.quantityHistory=JSON.parse(p)||[],this.appliedPromos=JSON.parse(m)||[],this.createdAt=h||new Date().toISOString(),this.updatedAt=M||new Date().toISOString(),this.readyQuantity=j||0}static getAll(){return d.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new f(s))}static getById(t){const s=d.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new f(s):null}static getByOrderId(t){return d.prepare(`SELECT * FROM ${this.tableName} WHERE orderId = ?`).all(t).map(a=>new f(a))}async addQuantity(t,e=new Date().toISOString()){this.quantity+t>=0&&this.quantityHistory.push({quantity:t,timestamp:e}),this.quantity+=t,this.quantity<0&&(this.quantity=0);const s=await w.getById(this.menuItemId);this.subtotal=s.price*this.quantity;const a=await b.getActiveByMenuItemId(this.menuItemId);return this.calculatePromotions(e,a),this.updateTotals(),this.save()}calculatePromotions(t,e){const s=[...this.quantityHistory].sort((a,o)=>new Date(a.timestamp)-new Date(o.timestamp));e.forEach(a=>{let o=0;if(s.forEach(n=>{n.promoActive=!1,a.isValidAtTimestamp(n.timestamp)&&(o+=n.quantity)}),o>0){const n=a.calculateDiscount(o,o*this.getBasePrice(),this.getBasePrice());n>0?this.appliedPromos.push({promoId:a.id,promoName:a.name,quantity:o,discountApplied:n,timestamp:t,type:a.type}):this.appliedPromos=this.appliedPromos.filter(i=>i.promoId!==a.id)}})}getBasePrice(){return w.getById(this.menuItemId).price}updateTotals(){this.discountApplied=this.appliedPromos.at(-1)?.discountApplied||0,this.discountApplied=Math.min(this.discountApplied,this.subtotal),this.total=this.subtotal-this.discountApplied}checkStock(t){const e=g.getByMenuItemId(this.menuItemId),s=[],a=[],o=[];if(t>0)for(const n of e){const i=I.getById(n.inventoryProductId);if(!i.isActive){a.push(i);continue}if(i.stock-n.quantityUsed*t<0){s.push({...i,required:n.quantityUsed*t});continue}i.stock-n.quantityUsed*t<i.minStock&&o.push(i)}if(s.length===0&&a.length===0)for(const n of e){const i=I.getById(n.inventoryProductId),c=new W(i.stock),u=new W(n.quantityUsed),l=new W(t);i.stock=c.plus(u.times(l).negated()).toNumber(),i.save()}return{notEnoughStockItems:s,notActiveItems:a,lowStockItems:o}}save(){if(this.id)return this.#e();{const t=w.getById(this.menuItemId);return this.subtotal||(this.subtotal=t.price*this.quantity),this.#t()}}#t(){const e=d.prepare(`INSERT INTO ${f.tableName} (menuItemId, orderId, promoId, quantity, subtotal, discountApplied, total, promoName, comments, quantityHistory, appliedPromos, createdAt, updatedAt, readyQuantity)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(this.menuItemId,this.orderId,this.promoId,this.quantity,this.subtotal,this.discountApplied,this.total,this.promoName,this.comments,JSON.stringify(this.quantityHistory),JSON.stringify(this.appliedPromos),this.createdAt,this.updatedAt,this.readyQuantity);return this.id=e.lastInsertRowid,this.id}#e(){return d.prepare(`UPDATE ${f.tableName}
            SET menuItemId = ?, orderId = ?, promoId = ?, quantity = ?, subtotal = ?, discountApplied = ?, total = ?, promoName = ?, comments = ?, quantityHistory = ?, appliedPromos = ?, createdAt = ?, updatedAt = ?, readyQuantity = ?
            WHERE id = ?`).run(this.menuItemId,this.orderId,this.promoId,this.quantity,this.subtotal,this.discountApplied,this.total,this.promoName,this.comments,JSON.stringify(this.quantityHistory),JSON.stringify(this.appliedPromos),this.createdAt,this.updatedAt,this.readyQuantity,this.id).changes>0}delete(){if(!this.id)throw new Error("Cannot delete an unsaved OrderItem.");return d.prepare(`DELETE FROM ${f.tableName} WHERE id = ?`).run(this.id).changes>0}}class y{static{T(this,"Order")}static tableName='"Order"';constructor({id:t,customer:e,subtotal:s,discountTotal:a,total:o,tip:n,createdAt:i,updatedAt:c,paymentMethod:u,cancelledById:l,cancelledAt:p,cancelReason:m,status:h,claimedById:M,billedById:j,billedAt:P,ready:C}){this.id=t||null,this.customer=e,this.subtotal=s||0,this.discountTotal=a||0,this.total=o||0,this.tip=n||0,this.createdAt=i||null,this.updatedAt=c||null,this.paymentMethod=u||null,this.cancelledById=l||null,this.cancelledAt=p||null,this.cancelReason=m||null,this.status=h||"active",this.claimedById=M||null,this.billedById=j||null,this.billedAt=P||null,this.ready=!!C}static getAll(){return d.prepare(`SELECT * FROM ${this.tableName} ORDER BY createdAt DESC`).all().map(s=>new y(s))}static getAllPaginated(t=0,e=-1,s=null,a=null){let o=`SELECT * FROM ${this.tableName}`,n=[],i=[];s&&(i.push("createdAt >= ?"),n.push(s)),a&&(i.push("createdAt <= ?"),n.push(a)),i.length>0&&(o+=` WHERE ${i.join(" AND ")}`),o+=" ORDER BY updatedAt DESC";let c=`SELECT COUNT(*) as total FROM ${this.tableName}`;i.length>0&&(c+=` WHERE ${i.join(" AND ")}`);let u;e!==-1?(o+=" LIMIT ? OFFSET ?",u=d.prepare(o).all(...n,e,t)):u=d.prepare(o).all(...n);const{total:l}=d.prepare(c).get(...n);return{orders:u.map(m=>new y(m)),total:l}}static getTotalSales(t=null,e=null){let s=`
      SELECT 
        COUNT(*) as orderCount,
        SUM(total) as totalSales,
        SUM(tip) as totalTips,
        SUM(discountTotal) as totalDiscounts
      FROM ${this.tableName}
      WHERE status != 'cancelled' AND status != 'unpaid'
    `,a=[];return t&&(s+=" AND createdAt >= ?",a.push(t)),e&&(s+=" AND createdAt <= ?",a.push(e)),d.prepare(s).get(...a)}static getDashboardStats(t=null,e=null,s=null){let a=[],o="",n="";t&&(o+=" AND o.createdAt >= ?",a.push(t)),e&&(o+=" AND o.createdAt <= ?",a.push(e)),s&&(n=" AND o.claimedById = ?",a.push(s));const i=`
  WITH 
  FilteredOrders AS (
    SELECT *
    FROM "Order" o 
    WHERE o.status NOT IN ('cancelled','unpaid')
      ${o}
      ${n}
  )
  SELECT 
    SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as activeOrders,
    SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelledOrders,
    SUM(CASE WHEN status = 'paid' THEN 1 ELSE 0 END) as completedOrders,
    SUM(total) as totalSales,
    SUM(tip) as totalTips,
    SUM(discountTotal) as totalDiscounts,
    COUNT(*) as orderCount,
    AVG(total) as averageOrderValue,
    AVG(
      (JULIANDAY(billedAt) - JULIANDAY(createdAt)) * 24 * 60
    ) as averageTimeBetweenCreatedAndBilled
  FROM FilteredOrders
`,c=`
    SELECT 
      strftime('%H:00', datetime(o.createdAt, 'localtime')) as hour,
      COUNT(*) as orderCount
    FROM "Order" o
    WHERE o.status NOT IN ('cancelled', 'unpaid')
      ${o}
      ${n}
    GROUP BY hour
    ORDER BY hour ASC
  `,u=`
  SELECT 
    COUNT(*) as orderCount,
    COALESCE(SUM(total), 0) totalSales,
    COALESCE(SUM(tip), 0) as totalTips,
    COALESCE(SUM(discountTotal), 0) as totalDiscounts
  FROM "Order" o
  WHERE status NOT IN ('cancelled', 'unpaid')
    ${n}
`,l=`
    SELECT 
      m.name as itemName,
      SUM(oi.quantity) as totalQuantity,
      SUM(oi.total) as totalRevenue
    FROM OrderItem oi
    JOIN MenuItem m ON oi.menuItemId = m.id
    JOIN "Order" o ON oi.orderId = o.id
    WHERE o.status NOT IN ('cancelled', 'unpaid')
      ${o}
      ${n}
    GROUP BY oi.menuItemId
    ORDER BY totalQuantity DESC
    LIMIT 5
  `,p=`
  WITH DateRanges AS (
    SELECT 
      MIN(o.createdAt) as earliest_date,
      MAX(o.createdAt) as latest_date,
      (JULIANDAY(MAX(o.createdAt)) - JULIANDAY(MIN(o.createdAt))) as date_diff_days
    FROM "Order" o
    WHERE o.status NOT IN ('cancelled', 'unpaid')
      ${o}
      ${n}
  )
  SELECT 
    CASE 
      WHEN (SELECT date_diff_days FROM DateRanges) <= 31 THEN
        date(o.createdAt, 'localtime')
      WHEN (SELECT date_diff_days FROM DateRanges) <= 182 THEN
        date(o.createdAt, 'localtime', 'weekday 0', '-7 days')
      WHEN (SELECT date_diff_days FROM DateRanges) <= 730 THEN
        date(o.createdAt, 'localtime', 'start of month')
      ELSE
        date(o.createdAt, 'localtime', 'start of year')
    END as period_start,
    COUNT(*) as order_count,
    SUM(o.total) as total_sales,
    SUM(o.tip) as total_tips,
    SUM(o.discountTotal) as total_discounts
  FROM "Order" o
  WHERE o.status NOT IN ('cancelled', 'unpaid')
    ${o}
    ${n}
  GROUP BY period_start
  ORDER BY period_start ASC
  `,m=[...a,...a],h=d.prepare(i).get(...a),M=s?d.prepare(u).get(s):d.prepare(u).get(),j=d.prepare(c).all(...a),P=d.prepare(l).all(...a),C=d.prepare(p).all(...m);let Q="daily";if(C.length>0){const v=new Date(C[0].period_start),G=C[1]?new Date(C[1].period_start):null;if(G){const V=(G-v)/864e5;V>=365?Q="yearly":V>=28?Q="monthly":V>=7&&(Q="weekly")}}return{activeOrders:h.activeOrders||0,cancelledOrders:h.cancelledOrders||0,completedOrders:h.completedOrders||0,totalSales:h.totalSales||0,totalTips:h.totalTips||0,totalDiscounts:h.totalDiscounts||0,orderCount:h.orderCount||0,historicTotals:M,averageOrderValue:Math.round((h.averageOrderValue||0)*100)/100,conversionRate:h.orderCount?parseFloat((h.completedOrders/h.orderCount*100).toFixed(2)):0,averageTimeBetweenCreatedAndBilled:Math.round((h.averageTimeBetweenCreatedAndBilled||0)*100)/100,hourlyDistribution:j,topSellingItems:P.map(v=>({name:v.itemName,quantity:v.totalQuantity,revenue:v.totalRevenue})),period:{startDate:t||"all time",endDate:e||"now"},salesByPeriod:{type:Q,data:C.map(v=>({periodStart:v.period_start,orderCount:v.order_count,totalSales:v.total_sales||0,totalTips:v.total_tips||0,totalDiscounts:v.total_discounts||0}))}}}static getByStatus(t){return d.prepare(`SELECT * FROM ${this.tableName} WHERE status = ?`).all(t).map(a=>new y(a))}static getActiveByClaimedId(t){return d.prepare(`SELECT * FROM ${this.tableName} WHERE claimedById = ? AND status = 'active'`).all(t).map(a=>new y(a))}static getById(t){const s=d.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new y(s):null}static getByCustomer(t){return d.prepare(`SELECT * FROM ${this.tableName} WHERE customer = ?`).all(t).map(a=>new y(a))}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=d.prepare(`INSERT INTO ${y.tableName} (customer, subtotal, discountTotal, total, tip, paymentMethod, status, claimedById, billedById, billedAt, createdAt, updatedAt, ready)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(this.customer,this.subtotal,this.discountTotal,this.total,this.tip,this.paymentMethod,this.status,this.claimedById,this.billedById,this.billedAt,this.createdAt,this.updatedAt,this.ready?1:0);return this.id=e.lastInsertRowid,this.id}#e(){return d.prepare(`UPDATE ${y.tableName}
            SET customer = ?, subtotal = ?, discountTotal = ?, total = ?, tip = ?, paymentMethod = ?, cancelledById = ?, cancelledAt = ?, cancelReason = ?, status = ?, claimedById = ?, billedById = ?, billedAt = ?, createdAt = ?, updatedAt = ?, ready = ?
            WHERE id = ?`).run(this.customer,this.subtotal,this.discountTotal,this.total,this.tip,this.paymentMethod,this.cancelledById,this.cancelledAt,this.cancelReason,this.status,this.claimedById,this.billedById,this.billedAt,this.createdAt,this.updatedAt,this.ready?1:0,this.id).changes>0}getEnhancedOrder(){const t=f.getByOrderId(this.id);let e=0,s=0;t.forEach(o=>{e+=o.subtotal,s+=o.discountApplied});const a=e-s<0?0:e-s;return{...this,orderItems:t,subtotal:e,discountTotal:s,total:a}}updateTotals(){const t=f.getByOrderId(this.id);let e=0,s=0;t.forEach(a=>{e+=a.subtotal,s+=a.discountApplied}),this.subtotal=e,this.discountTotal=s,this.total=e-s<0?0:e-s}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Order.");return d.prepare(`DELETE FROM ${y.tableName} WHERE id = ?`).run(this.id).changes>0}}const R=B();R.get("/",(r,t)=>{try{const e=parseInt(r.query.page)||1,s=parseInt(r.query.limit)||-1,a=(e-1)*(s===-1?0:s);let o=r.query.startDate?new Date(r.query.startDate):null,n=r.query.endDate?new Date(r.query.endDate):null;if(o&&isNaN(o.getTime())||n&&isNaN(n.getTime()))return t.status(400).json({error:"Invalid date format"});o=o?.toISOString(),n=n?.toISOString();const{orders:i,total:c}=y.getAllPaginated(a,s,o,n),l={orders:i.map(p=>p.getEnhancedOrder()),total:c};s!==-1&&(l.pagination={page:e,limit:s,totalPages:Math.ceil(c/s)}),t.json(l)}catch(e){t.status(500).json({error:"Failed to fetch orders. "+e.message})}}),R.get("/dashboard-stats",(r,t)=>{try{let e=r.query.startDate?new Date(r.query.startDate):null,s=r.query.endDate?new Date(r.query.endDate):null,a=r.query.claimedById||null;if(e&&isNaN(e.getTime())||s&&isNaN(s.getTime()))return t.status(400).json({error:"Invalid date format"});e=e?.toISOString(),s=s?.toISOString();const o=y.getDashboardStats(e,s,a);t.json(o)}catch(e){t.status(500).json({error:"Failed to fetch dashboard stats. "+e.message})}}),R.get("/total-sales",(r,t)=>{try{let e=r.query.startDate?new Date(r.query.startDate):null,s=r.query.endDate?new Date(r.query.endDate):null;if(e&&isNaN(e.getTime())||s&&isNaN(s.getTime()))return t.status(400).json({error:"Invalid date format"});e=e?.toISOString(),s=s?.toISOString();const a=y.getTotalSales(e,s);t.json(a)}catch(e){t.status(500).json({error:"Failed to fetch total sales. "+e.message})}}),R.get("/active",(r,t)=>{try{const s=y.getByStatus("active").map(a=>a.getEnhancedOrder());t.json({orders:s})}catch(e){t.status(500).json({error:"Failed to fetch orders. "+e.message})}}),R.get("/active-orders-by-agent/:agentId",(r,t)=>{try{const{agentId:e}=r.params,a=y.getActiveByClaimedId(e).map(o=>o.getEnhancedOrder());t.json({orders:a})}catch(e){t.status(500).json({error:"Failed to fetch orders. "+e.message})}}),R.get("/:id",(r,t)=>{const e=r.params.id,s=y.getById(e);if(!s)return t.status(404).json({message:"Order not found"});const a=f.getByOrderId(e);let o=0,n=0;a.forEach(c=>{o+=c.subtotal,n+=c.discountApplied});const i=o-n<0?0:o-n;s.subtotal=o,s.discountTotal=n,s.total=i,t.json({...s,orderItems:a})}),R.post("/",(r,t)=>{try{const e=new y(r.body);e.createdAt=new Date().toISOString(),e.updatedAt=new Date().toISOString(),e.save();const s=e.getEnhancedOrder();r.io.emit("orderChanged",{action:"created",order:s}),t.status(201).json(s)}catch(e){console.log(e),t.status(500).json({error:"Failed to create order. "+e.message})}}),R.put("/:id",(r,t)=>{try{const{id:e}=r.params,s=y.getById(Number(e));if(s){Object.assign(s,r.body),s.updatedAt=new Date().toISOString(),s.save();const a=s.getEnhancedOrder();r.io.emit("orderChanged",{action:"updated",order:a}),t.json({message:"Order updated successfully."})}else t.status(404).json({error:"Order not found."})}catch(e){t.status(500).json({error:"Failed to update order. "+e.message})}}),R.delete("/:id",(r,t)=>{try{const{id:e}=r.params,s=y.getById(Number(e));s?(s.delete(),r.io.emit("orderChanged",{action:"deleted",orderId:e}),t.json({message:"Order deleted successfully."})):t.status(404).json({error:"Order not found."})}catch(e){t.status(500).json({error:"Failed to delete order. "+e.message})}}),R.get("/:orderId/order-items",(r,t)=>{try{const{orderId:e}=r.params,s=f.getByOrderId(Number(e));t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch order items. "+e.message})}}),R.put("/:id/charge",async(r,t)=>{try{const{id:e}=r.params,{paymentMethod:s,billedById:a}=r.body,o=y.getById(Number(e));if(!o)return t.status(404).json({message:"Order not found"});o.paymentMethod=s,o.status="paid",o.billedById=a,o.billedAt=new Date().toISOString(),o.updateTotals(),o.save();const n=o.getEnhancedOrder();r.io.emit("orderChanged",{action:"updated",order:n}),t.json({message:"Order charged successfully."})}catch(e){t.status(500).json({error:"Failed to charge order. "+e.message})}}),R.put("/:id/cancel",async(r,t)=>{try{const{id:e}=r.params,{cancelReason:s}=r.body,a=y.getById(Number(e));if(!a)return t.status(404).json({message:"Order not found"});a.status="cancelled",a.cancelledAt=new Date().toISOString(),a.cancelReason=s,a.save(),f.getByOrderId(Number(e)).forEach(i=>{const c=g.getByMenuItemId(i.menuItemId);for(const u of c){const l=I.getById(u.inventoryProductId);l.stock+=u.quantityUsed*i.quantity,l.save()}i.delete()});const n=a.getEnhancedOrder();r.io.emit("orderChanged",{action:"updated",order:n}),t.status(200).json({message:"Order cancelled successfully",order:a})}catch(e){console.log(e),t.status(500).json({message:"Server error",error:e})}}),R.put("/:id/unpay",async(r,t)=>{try{const{id:e}=r.params,s=y.getById(Number(e));if(!s)return t.status(404).json({message:"Order not found"});s.status="unpaid",s.billedById=null,s.billedAt=null,s.save();const a=s.getEnhancedOrder();r.io.emit("orderChanged",{action:"updated",order:a}),t.json({message:"Order status updated successfully."})}catch(e){t.status(500).json({error:"Failed to update order status. "+e.message})}}),R.patch("/:id/tip",(r,t)=>{try{const{id:e}=r.params,{tip:s}=r.body;if(s===void 0)return t.status(400).json({error:"Tip amount is required"});const a=y.getById(Number(e));if(!a)return t.status(404).json({message:"Order not found"});a.tip+=s,a.save();const o=a.getEnhancedOrder();r.io.emit("orderChanged",{action:"updated",order:o}),t.json({message:"Tip added successfully",order:o})}catch(e){t.status(500).json({error:"Failed to add tip. "+e.message})}});const N=B();N.get("/",(r,t)=>{try{const e=b.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch promotions. "+e.message})}}),N.post("/promos-with-availability",(r,t)=>{try{const{availability:e,...s}=r.body;if(!["price_discount","percentage_discount","buy_x_get_y"].includes(s.type))return t.status(400).json({error:"Invalid promo type. Must be 'discount' or 'buy_x_get_y'."});s.startDate=s.startDate?new Date(s.startDate).toISOString():null,s.endDate=s.endDate?new Date(s.endDate).toISOString():null,s.buy_quantity=s.buy_quantity??null,s.pay_quantity=s.pay_quantity??null,s.price_discount=s.discount??null,s.percentage_discount=s.percentage??null;const a=new b(s);a.save();const o=a.id;e&&Object.entries(e).forEach(([i,c])=>{c&&c.startTime&&c.endTime&&new E({promoId:o,dayOfWeek:i.charAt(0).toUpperCase()+i.slice(1),startTime:c.startTime,endTime:c.endTime}).save()}),t.status(201).json({id:o,message:"Promo and availability created successfully."})}catch(e){console.error(e),t.status(500).json({error:`Failed to create promo and availability. ${e.message}`})}}),N.put("/promos-with-availability/:id",async(r,t)=>{try{const e=r.params.id,{availability:s,...a}=r.body,o=b.getById(e);if(!o)return t.status(404).json({error:"Promo not found."});Object.assign(o,a),o.save(),s&&(o.getRecurrenceRules().forEach(i=>i.delete()),Object.entries(s).forEach(([i,c])=>{c&&c.startTime&&c.endTime&&new E({promoId:o.id,dayOfWeek:i.charAt(0).toUpperCase()+i.slice(1),startTime:c.startTime,endTime:c.endTime}).save()})),t.status(200).json({id:o.id,message:"Promo and availability updated successfully."})}catch(e){console.error(e),t.status(500).json({error:`Failed to update promo and availability. ${e.message}`})}}),N.delete("/promos-with-availability/:id",async(r,t)=>{try{const e=r.params.id,s=b.getById(e);if(!s)return t.status(404).json({error:"Promo not found."});if(!s.delete())return t.status(500).json({error:"Failed to delete the promo."});t.status(200).json({message:"Promo and its availability successfully deleted."})}catch(e){console.error("Error in DELETE promo:",e),t.status(500).json({error:`Failed to delete promo and its availability. ${e.message}`})}}),N.get("/promos-with-availability",(r,t)=>{try{const s=b.getAll().map(a=>{const o=E.getByPromoId(a.id),n={Monday:{startTime:null,endTime:null},Tuesday:{startTime:null,endTime:null},Wednesday:{startTime:null,endTime:null},Thursday:{startTime:null,endTime:null},Friday:{startTime:null,endTime:null},Saturday:{startTime:null,endTime:null},Sunday:{startTime:null,endTime:null}};return o.forEach(i=>{n[i.dayOfWeek]={startTime:i.startTime,endTime:i.endTime}}),{...a,availability:n}});t.json(s)}catch(e){console.error(e),t.status(500).json({error:"Failed to fetch promotions with availability."})}}),N.get("/:id",(r,t)=>{try{const{id:e}=r.params,s=b.getById(Number(e));s?t.json(s):t.status(404).json({error:"Promotion not found."})}catch(e){t.status(500).json({error:"Failed to fetch promotion. "+e.message})}}),N.post("/",(r,t)=>{try{const s=new b(r.body).save();t.status(201).json({id:s})}catch(e){t.status(500).json({error:"Failed to create promotion. "+e.message})}}),N.put("/:id",(r,t)=>{try{const{id:e}=r.params,s=b.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"Promotion updated successfully."})):t.status(404).json({error:"Promotion not found."})}catch(e){t.status(500).json({error:"Failed to update promotion. "+e.message})}}),N.delete("/:id",(r,t)=>{try{const{id:e}=r.params,s=b.getById(Number(e));s?(s.delete(),t.json({message:"Promotion deleted successfully."})):t.status(404).json({error:"Promotion not found."})}catch(e){t.status(500).json({error:"Failed to delete promotion. "+e.message})}}),N.get("/:id/recurrence-rules",(r,t)=>{try{const{id:e}=r.params,s=b.getById(Number(e));if(s){const a=s.getRecurrenceRules();t.json(a)}else t.status(404).json({error:"Promotion not found."})}catch(e){t.status(500).json({error:"Failed to fetch recurrence rules. "+e.message})}}),N.post("/:id/recurrence-rules",(r,t)=>{try{const{id:e}=r.params;if(b.getById(Number(e))){const o=new E({...r.body,promoId:Number(e)}).save();t.status(201).json({recurrenceId:o})}else t.status(404).json({error:"Promotion not found."})}catch(e){t.status(500).json({error:"Failed to create recurrence rule. "+e.message})}}),N.put("/recurrence-rules/:id",(r,t)=>{try{const{id:e}=r.params,s=E.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"Recurrence rule updated successfully."})):t.status(404).json({error:"Recurrence rule not found."})}catch(e){t.status(500).json({error:"Failed to update recurrence rule. "+e.message})}}),N.delete("/promos/recurrence-rules/:id",(r,t)=>{try{const{id:e}=r.params,s=E.getById(Number(e));s?(s.delete(),t.json({message:"Recurrence rule deleted successfully."})):t.status(404).json({error:"Recurrence rule not found."})}catch(e){t.status(500).json({error:"Failed to delete recurrence rule. "+e.message})}}),N.get("/recurrent-dates",(r,t)=>{try{const e=E.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch recurrent dates. "+e.message})}}),N.get("/recurrent-dates/promo/:promoId",(r,t)=>{try{const{promoId:e}=r.params,s=E.getByPromoId(Number(e));t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch recurrent dates for promo. "+e.message})}}),N.post("/recurrent-dates",(r,t)=>{try{const s=new E(r.body).save();t.status(201).json({id:s})}catch(e){t.status(500).json({error:"Failed to create recurrent date. "+e.message})}}),N.put("/recurrent-dates/:id",(r,t)=>{try{const{id:e}=r.params,s=E.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"RecurrentDate updated successfully."})):t.status(404).json({error:"RecurrentDate not found."})}catch(e){t.status(500).json({error:"Failed to update recurrent date. "+e.message})}}),N.delete("/recurrent-dates/:id",(r,t)=>{try{const{id:e}=r.params,s=E.getById(Number(e));s?(s.delete(),t.json({message:"RecurrentDate deleted successfully."})):t.status(404).json({error:"RecurrentDate not found."})}catch(e){t.status(500).json({error:"Failed to delete recurrent date. "+e.message})}});class O{static{T(this,"Category")}static tableName="Category";constructor({id:t,name:e,description:s,type:a}){this.id=t||null,this.name=e,this.description=s,this.type=a}static getAll(){return d.prepare(`SELECT * FROM ${this.tableName} ORDER BY name ASC`).all().map(s=>new O(s))}static getById(t){const s=d.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new O(s):null}static getAllByType(t){return d.prepare(`SELECT * FROM ${this.tableName} WHERE type = ? ORDER BY name ASC`).all(t).map(a=>new O(a))}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=d.prepare(`INSERT INTO ${O.tableName} (name, description, type)
            VALUES (?, ?, ?)`).run(this.name,this.description,this.type);return this.id=e.lastInsertRowid,this.id}#e(){return d.prepare(`UPDATE ${O.tableName}
            SET name = ?, description = ?, type = ?
            WHERE id = ?`).run(this.name,this.description,this.type,this.id).changes}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Category.");return d.prepare(`DELETE FROM ${O.tableName} WHERE id = ?`).run(this.id).changes>0}}const k=B();k.get("/",(r,t)=>{try{const{type:e}=r.query;let s;e?s=O.getAllByType(e):s=O.getAll(),t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch categories. "+e.message})}}),k.get("/:id",(r,t)=>{try{const{id:e}=r.params,s=O.getById(Number(e));s?t.json(s):t.status(404).json({error:"Category not found."})}catch(e){t.status(500).json({error:"Failed to fetch category. "+e.message})}}),k.post("/",(r,t)=>{try{const s=new O(r.body).save();t.status(201).json({id:s})}catch(e){t.status(500).json({error:"Failed to create category. "+e.message})}}),k.put("/:id",(r,t)=>{try{const{id:e}=r.params,s=O.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"Category updated successfully."})):t.status(404).json({error:"Category not found."})}catch(e){t.status(500).json({error:"Failed to update category. "+e.message})}}),k.delete("/:id",(r,t)=>{try{const{id:e}=r.params,s=O.getById(Number(e));s?(s.delete(),t.json({message:"Category deleted successfully."})):t.status(404).json({error:"Category not found."})}catch(e){console.log(e),t.status(500).json({error:"Failed to delete category. "+e.message})}});class D{static{T(this,"Supplier")}static tableName="Supplier";constructor({id:t,name:e,phone:s,email:a,address:o}){this.id=t||null,this.name=e,this.phone=s||null,this.email=a||null,this.address=o||null}static getAll(){return d.prepare(`SELECT * FROM ${this.tableName} ORDER BY name ASC`).all().map(s=>new D(s))}static getById(t){const s=d.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new D(s):null}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=d.prepare(`INSERT INTO ${D.tableName} (name, phone, email, address)
            VALUES (?, ?, ?, ?)`).run(this.name,this.phone,this.email,this.address);return this.id=e.lastInsertRowid,this.id}#e(){return d.prepare(`UPDATE ${D.tableName}
            SET name = ?, phone = ?, email = ?, address = ?
            WHERE id = ?`).run(this.name,this.phone,this.email,this.address,this.id).changes}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Supplier.");return d.prepare(`DELETE FROM ${D.tableName} WHERE id = ?`).run(this.id).changes>0}}const U=B();U.get("/",(r,t)=>{try{const e=D.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch suppliers. "+e.message})}}),U.get("/:id",(r,t)=>{try{const{id:e}=r.params,s=D.getById(Number(e));s?t.json(s):t.status(404).json({error:"Supplier not found."})}catch(e){t.status(500).json({error:"Failed to fetch supplier. "+e.message})}}),U.post("/",(r,t)=>{try{const s=new D(r.body).save();t.status(201).json({id:s})}catch(e){t.status(500).json({error:"Failed to create supplier. "+e.message})}}),U.put("/:id",(r,t)=>{try{const{id:e}=r.params,s=D.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"Supplier updated successfully."})):t.status(404).json({error:"Supplier not found."})}catch(e){t.status(500).json({error:"Failed to update supplier. "+e.message})}}),U.delete("/:id",(r,t)=>{try{const{id:e}=r.params,s=D.getById(Number(e));s?(s.delete(),t.json({message:"Supplier deleted successfully."})):t.status(404).json({error:"Supplier not found."})}catch(e){t.status(500).json({error:"Failed to delete supplier. "+e.message})}});class F{static{T(this,"Agent")}static tableName="Agent";constructor({id:t,name:e,lastName:s,image:a,address:o,phone:n,rfc:i,email:c,pin:u,role:l,isActive:p}){this.id=t||null,this.name=e,this.lastName=s,this.image=a||null,this.address=o,this.phone=n,this.rfc=i,this.email=c,this.pin=u,this.role=l,this.isActive=!!p}static getAll(){return d.prepare(`SELECT id, name, lastName, email, role, isActive FROM ${this.tableName} ORDER BY name ASC`).all().map(s=>new F(s))}static getById(t){const s=d.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new F(s):null}static getByEmail(t){const s=d.prepare(`SELECT * FROM ${this.tableName} WHERE email = ?`).get(t);return s?new F(s):null}async save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=d.prepare(`INSERT INTO ${F.tableName} (name, lastName, image, address, phone, rfc, email, pin, role, isActive)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(this.name,this.lastName,this.image,this.address,this.phone,this.rfc,this.email,this.pin,this.role,this.isActive);return this.id=e.lastInsertRowid,this.id}#e(){return d.prepare(`UPDATE ${F.tableName}
            SET name = ?, lastName = ?, image = ?, address = ?, phone = ?, rfc = ?, email = ?, pin = ?, role = ?, isActive = ?
            WHERE id = ?`).run(this.name,this.lastName,this.image,this.address,this.phone,this.rfc,this.email,this.pin,this.role,this.isActive,this.id).changes}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Agent.");return d.prepare(`DELETE FROM ${F.tableName} WHERE id = ?`).run(this.id).changes>0}static async authenticate(t,e){const s=this.getByEmail(t);return!s||!s.isActive||s.pin!==e?null:s}}ct.config();const tt=process.env.JWT_SECRET_KEY,yt=T((r,t="24h")=>{try{return _.sign(r,tt,{expiresIn:t})}catch(e){throw new Error(`Error generating token: ${e.message}`)}},"generateToken"),gt=T(r=>{try{return _.verify(r,tt)}catch{throw new Error("Invalid or expired token.")}},"verifyToken"),It=T((r,t,e,s,a)=>({role:r,email:t,name:e,lastName:s,id:a}),"generateJwtPayload"),et=T((r,t,e)=>{try{const s=r.headers.authorization;if(!s||!s.startsWith("Bearer "))return t.status(401).json({message:"Unauthorized: No token provided"});const a=s.split(" ")[1],o=gt(a);r.user=o,e()}catch{t.status(401).json({message:"Unauthorized: Invalid or expired token"})}},"authenticate"),X=B();X.post("/",async(r,t)=>{const{email:e,pin:s}=r.body;if(!e||!s)return t.status(400).json({status:"error",message:"Missing required fields: email, pin are required."});try{let a=await F.authenticate(e,s);if(!a||a.length===0)return t.status(404).json({message:"Credenciales inv\xE1lidas"});let o=It(a.role,a.email,a.name,a.lastName,a.id),n=yt(o,"24h");t.status(200).json({token:n})}catch(a){console.log(a),t.status(500).json({error:a.message})}}),X.get("/",et,async(r,t)=>{try{t.status(200).json({message:"valid"})}catch(e){t.status(500).json({error:e.message})}});const $=B();$.get("/",(r,t)=>{try{const e=f.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch order items. "+e.message})}}),$.post("/",async(r,t)=>{try{const{menuItemId:e,orderId:s,quantity:a,comments:o}=r.body,n=new Date().toISOString();if(!w.getById(e))return t.status(400).json({error:"El MenuItem proporcionado no existe."});const c=new f({menuItemId:e,orderId:s,quantity:0,subtotal:0,comments:o,quantityHistory:"[]",appliedPromos:"[]",createdAt:n,updatedAt:n}),{notEnoughStockItems:u,notActiveItems:l,lowStockItems:p}=c.checkStock(a);if(l.length>0)return t.status(400).json({error:"Hay insumos que no est\xE1n activos",notActiveItems:l});if(u.length>0)return t.status(400).json({error:"No hay suficientes insumos para agregar esto",notEnoughStockItems:u});await c.save(),await c.addQuantity(a,n);const m=y.getById(s);m.updatedAt=n,m.ready=!1,await m.save();const h=m.getEnhancedOrder();r.io.emit("orderChanged",{action:"updated",order:h}),t.status(201).json({orderItem:c,order:h,lowStockItems:p,quantity:a})}catch(e){console.error("Error creating OrderItem:",e),t.status(500).json({error:e.message})}}),$.put("/:id/quantity",async(r,t)=>{const{id:e}=r.params,{quantity:s,timestamp:a,comments:o}=r.body;try{const n=await f.getById(e);if(!n)return t.status(404).json({error:"OrderItem not found"});if(n.quantity+s<0)return t.status(400).json({error:"No se puede reducir m\xE1s la cantidad de el item"});const{notEnoughStockItems:i,notActiveItems:c,lowStockItems:u}=n.checkStock(s);if(c.length>0)return t.status(400).json({error:"Hay insumos que no est\xE1n activos",notActiveItems:c});if(i.length>0)return t.status(400).json({error:"No hay suficientes insumos para agregar esto",notEnoughStockItems:i});o&&(n.comments=o),n.updatedAt=a,await n.save(),await n.addQuantity(s,a);const l=y.getById(n.orderId);l.updatedAt=a;const p=f.getByOrderId(n.orderId);l.ready=p.every(h=>h.readyQuantity>=h.quantity),await l.save();const m=l.getEnhancedOrder();r.io.emit("orderChanged",{action:"updated",order:m}),t.json({orderItem:n,order:m,lowStockItems:u,quantity:s})}catch(n){t.status(500).json({error:n.message})}}),$.delete("/:id",async(r,t)=>{const{id:e}=r.params;try{const s=await f.getById(e);if(!s)return t.status(404).json({error:"OrderItem not found"});const a=y.getById(s.orderId),o=g.getByMenuItemId(s.menuItemId);for(const i of o){const c=I.getById(i.inventoryProductId),u=new W(c.stock),l=new W(i.quantityUsed),p=new W(s.quantity);c.stock=u.plus(l.times(p)).toNumber(),c.save()}await s.delete();const n=a.getEnhancedOrder();r.io.emit("orderChanged",{action:"updated",order:n}),t.json(n)}catch(s){console.error("Error deleting OrderItem:",s),t.status(500).json({error:s.message})}}),$.put("/:id/ready-quantity",async(r,t)=>{const{id:e}=r.params,{readyQuantity:s}=r.body;try{const a=await f.getById(e);if(!a)return t.status(404).json({error:"OrderItem not found"});if(a.readyQuantity=a.readyQuantity+s,a.readyQuantity<0)return t.status(400).json({error:"La cantidad lista no puede ser menor a 0"});if(a.readyQuantity>a.quantity)return t.status(400).json({error:"La cantidad lista no puede ser mayor a la cantidad total"});await a.save();const o=y.getById(a.orderId),n=f.getByOrderId(a.orderId);o.ready=n.every(c=>c.readyQuantity>=c.quantity),await o.save();const i=o.getEnhancedOrder();r.io.emit("orderChanged",{action:"updated",order:i}),t.json({order:i})}catch(a){t.status(500).json({error:a.message})}}),$.put("/:id/comments",async(r,t)=>{const{id:e}=r.params,{comments:s}=r.body;try{const a=await f.getById(e);if(!a)return t.status(404).json({error:"OrderItem not found"});a.comments=s,await a.save();const n=y.getById(a.orderId).getEnhancedOrder();r.io.emit("orderChanged",{action:"updated",order:n}),t.json(a)}catch(a){console.log(a),t.status(500).json({error:a.message})}});const st=B();st.get("/",(r,t)=>{try{const e={restaurantName:process.env.RESTAURANT_NAME,securityPin:process.env.SECURITY_PIN};t.json(e)}catch{t.status(500).json({error:"Error al leer la configuraci\xF3n"})}});const A=Y();A.use(Y.json()),A.use(it()),A.use((r,t,e)=>{r.io=A.get("io"),e()}),A.use("/authenticate",X),A.use(et),A.use("/items",q),A.use("/agents",L),A.use("/menu",S),A.use("/orders",R),A.use("/order-items",$),A.use("/promos",N),A.use("/categories",k),A.use("/suppliers",U),A.use("/config",st),A.use("/images",Y.static("storage/images"));const rt=3e3,at=ut.createServer(A),ot=new lt(at,{cors:{origin:"*",methods:["GET","POST"]}});A.set("io",ot),ot.on("connection",r=>{console.log("A user connected",r.handshake.address,new Date().toLocaleString()),r.on("disconnect",()=>{console.log("A user disconnected",r.handshake.address,new Date().toLocaleString())})}),at.listen(rt,()=>{console.log(process.env.RESTAURANT_NAME),console.log(`Server is running on http://localhost:${rt}`)});
