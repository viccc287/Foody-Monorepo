#!/usr/bin/env node
var K=Object.defineProperty;var g=(r,t)=>K(r,"name",{value:t,configurable:!0});import W,{Router as D}from"express";import Q from"cors";import Z from"better-sqlite3";import F from"path";import P from"fs";import z from"multer";import J from"jsonwebtoken";import _ from"dotenv";const x=F.resolve(),tt=F.resolve(x,"./database.sqlite"),c=new Z(tt),et=F.resolve(x,"./schema.sql"),st=P.readFileSync(et,"utf8");c.exec(st);const $=D();$.get("/",(r,t)=>{const n=c.prepare("SELECT * FROM Item").all().map(o=>({...o,isActive:!!o.isActive,variablePrice:!!o.variablePrice,printLocations:JSON.parse(o.printLocations||"[]")}));t.json(n)}),$.post("/",(r,t)=>{const{name:e,quantity:s,unit:n,isActive:o,category:a,supplier:i,printLocations:d,variablePrice:u,recipe:l,price:p}=r.body,T=c.prepare(`INSERT INTO Item (name, quantity, unit, isActive, category, supplier, printLocations, variablePrice, recipe, price)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(e,s,n,o?1:0,a,i,JSON.stringify(d),u?1:0,l,p);t.json({id:T.lastInsertRowid}),console.log(`Item ADDED by USER at ${new Date().toLocaleString("es-MX")}`)}),$.put("/:id",(r,t)=>{const{id:e}=r.params,{name:s,quantity:n,unit:o,isActive:a,category:i,supplier:d,printLocations:u,variablePrice:l,recipe:p,price:m}=r.body;c.prepare(`UPDATE Item
     SET name = ?, quantity = ?, unit = ?, isActive = ?, category = ?, supplier = ?, printLocations = ?, variablePrice = ?, recipe = ?, price = ?
     WHERE id = ?`).run(s,n,o,a?1:0,i,d,JSON.stringify(u),l?1:0,p,m,e).changes>0?(t.json({message:"Item updated successfully"}),console.log(`Item UPDATED by USER at ${new Date().toLocaleString("es-MX")}`)):t.status(404).json({error:"Item not found"})}),$.delete("/:id",(r,t)=>{const{id:e}=r.params;c.prepare("DELETE FROM Item WHERE id = ?").run(e).changes>0?(t.json({message:"Item deleted successfully"}),console.log(`Item DELETED by USER at ${new Date().toLocaleString("es-MX")}`)):t.status(404).json({error:"Item not found"})});const M=D();M.get("/",(r,t)=>{const n=c.prepare("SELECT * FROM Agent").all().map(o=>({...o,isActive:!!o.isActive}));t.json(n)}),M.get("/names",(r,t)=>{const s=c.prepare("SELECT id, name, lastName FROM Agent").all();t.json(s)}),M.post("/",(r,t)=>{const{name:e,lastName:s,image:n,address:o,phone:a,rfc:i,email:d,pin:u,role:l,isActive:p}=r.body,T=c.prepare(`INSERT INTO Agent (name, lastName, image, address, phone, rfc, email, pin, role, isActive)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(e,s,n,o,a,i,d,u,l,p?1:0);t.json({id:T.lastInsertRowid}),console.log(`Agent ADDED by USER at ${new Date().toLocaleString("es-MX")}`)}),M.put("/:id",(r,t)=>{const{id:e}=r.params,{name:s,lastName:n,image:o,address:a,phone:i,rfc:d,email:u,pin:l,role:p,isActive:m}=r.body;c.prepare(`UPDATE Agent
     SET name = ?, lastName = ?, image = ?, address = ?, phone = ?, rfc = ?, email = ?, pin = ?, role = ?, isActive = ?
     WHERE id = ?`).run(s,n,o,a,i,d,u,l,p,m?1:0,e).changes>0?(t.json({message:"Agent updated successfully"}),console.log(`Agent UPDATED by USER at ${new Date().toLocaleString("es-MX")}`)):t.status(404).json({error:"Agent not found"})}),M.delete("/:id",(r,t)=>{const{id:e}=r.params;c.prepare("DELETE FROM Agent WHERE id = ?").run(e).changes>0?(t.json({message:"Agent deleted successfully"}),console.log(`Agent DELETED by USER at ${new Date().toLocaleString("es-MX")}`)):t.status(404).json({error:"Agent not found"})});const rt=z.diskStorage({destination:g((r,t,e)=>{const s="storage/images";P.existsSync(s)||P.mkdirSync(s,{recursive:!0}),e(null,s)},"destination"),filename:g((r,t,e)=>{const s=`agent-${Date.now()}-${Math.round(Math.random()*1e9)}${F.extname(t.originalname)}`;e(null,s)},"filename")}),nt=z({storage:rt,limits:{fileSize:5*1024*1024},fileFilter:g((r,t,e)=>{const s=/jpeg|jpg|png|webp/,n=s.test(F.extname(t.originalname).toLowerCase()),o=s.test(t.mimetype);n&&o?e(null,!0):e(new Error("Invalid file type. Only JPEG, PNG and WEBP allowed."))},"fileFilter")});M.post("/upload-image",nt.single("image"),(r,t)=>{try{if(!r.file)return t.status(400).json({error:"No file uploaded"});const e=`http://localhost:3000/images/${r.file.filename}`;t.json({imageUrl:e}),console.log(`Image uploaded by USER at ${new Date().toLocaleString("es-MX")}`)}catch(e){console.error("Upload error:",e),t.status(500).json({error:"Failed to upload image"})}});class w{static{g(this,"MenuItem")}static tableName="MenuItem";constructor({id:t,name:e,quantity:s,unit:n,isActive:o,categoryId:a,printLocations:i,variablePrice:d,price:u}){this.id=t||null,this.name=e,this.quantity=s,this.unit=n,this.isActive=!!o,this.categoryId=a,this.printLocations=Array.isArray(i)?i:JSON.parse(i||"[]"),this.variablePrice=d||!1,this.price=u}static getAll(){return c.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new w(s))}static getById(t){const s=c.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new w(s):null}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=c.prepare(`INSERT INTO ${w.tableName} (name, quantity, unit, isActive, categoryId, printLocations, variablePrice, price)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`).run(this.name,this.quantity,this.unit,this.isActive?1:0,this.categoryId,JSON.stringify(this.printLocations),this.variablePrice?1:0,this.price);return this.id=e.lastInsertRowid,this.id}#e(){return c.prepare(`UPDATE ${w.tableName}
            SET name = ?, quantity = ?, unit = ?, isActive = ?, categoryId = ?, printLocations = ?, variablePrice = ?, price = ?
            WHERE id = ?`).run(this.name,this.quantity,this.unit,this.isActive?1:0,this.categoryId,JSON.stringify(this.printLocations),this.variablePrice?1:0,this.price,this.id).changes}delete(){if(!this.id)throw new Error("Cannot delete an unsaved MenuItem.");return c.prepare(`DELETE FROM ${w.tableName} WHERE id = ?`).run(this.id).changes>0}}class y{static{g(this,"Ingredient")}static tableName="Ingredients";constructor({id:t,menuItemId:e,inventoryProductId:s,quantityUsed:n}){this.id=t||null,this.menuItemId=e,this.inventoryProductId=s,this.quantityUsed=n}static getAll(){return c.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new y(s))}static getByMenuItemId(t){return c.prepare(`SELECT * FROM ${this.tableName} WHERE menuItemId = ?`).all(t).map(n=>new y(n))}static deleteByMenuItemId(t){return c.prepare(`DELETE FROM ${this.tableName} WHERE menuItemId = ?`).run(t).changes>0}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=c.prepare(`INSERT INTO ${y.tableName} (menuItemId, inventoryProductId, quantityUsed)
            VALUES (?, ?, ?)`).run(this.menuItemId,this.inventoryProductId,this.quantityUsed);return this.id=e.lastInsertRowid,this.id}#e(){return c.prepare(`UPDATE ${y.tableName}
            SET menuItemId = ?, inventoryProductId = ?, quantityUsed = ?
            WHERE id = ?`).run(this.menuItemId,this.inventoryProductId,this.quantityUsed,this.id).changes>0}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Ingredient.");return c.prepare(`DELETE FROM ${y.tableName} WHERE id = ?`).run(this.id).changes>0}}class I{static{g(this,"StockItem")}static tableName="StockItem";constructor({id:t,name:e,stock:s,unit:n,isActive:o,categoryId:a,supplierId:i,cost:d}){this.id=t||null,this.name=e,this.stock=s,this.unit=n,this.isActive=!!o,this.categoryId=a,this.supplierId=i,this.cost=d}static getAll(){return c.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new I(s))}static getById(t){const s=c.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new I(s):null}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=c.prepare(`INSERT INTO ${I.tableName} (name, stock, unit, isActive, categoryId, supplierId, cost)
            VALUES (?, ?, ?, ?, ?, ?, ?)`).run(this.name,this.stock,this.unit,this.isActive?1:0,this.categoryId,this.supplierId,this.cost);return this.id=e.lastInsertRowid,this.id}#e(){return c.prepare(`UPDATE ${I.tableName}
            SET name = ?, stock = ?, unit = ?, isActive = ?, categoryId = ?, supplierId = ?, cost = ?
            WHERE id = ?`).run(this.name,this.stock,this.unit,this.isActive?1:0,this.categoryId,this.supplierId,this.cost,this.id).changes>0}delete(){if(!this.id)throw new Error("Cannot delete an unsaved StockItem.");return c.prepare(`DELETE FROM ${I.tableName} WHERE id = ?`).run(this.id).changes>0}}const j=D();j.get("/menu-items",(r,t)=>{try{const e=w.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch menu items. "+e.message})}}),j.get("/menu-items/:id",(r,t)=>{try{const{id:e}=r.params,s=w.getById(Number(e));s?t.json(s):t.status(404).json({error:"MenuItem not found."})}catch(e){t.status(500).json({error:"Failed to fetch menu item. "+e.message})}}),j.get("/menu-items-with-ingredients",(r,t)=>{try{const s=w.getAll().map(n=>{const a=y.getByMenuItemId(n.id).map(i=>{const d=I.getById(i.inventoryProductId);return{...i,stockItem:d}});return{...n,ingredients:a}});t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch menu items with ingredients. "+e.message})}}),j.get("/menu-items/:id/ingredients",(r,t)=>{try{const{id:e}=r.params,s=w.getById(Number(e));if(s){const o=y.getByMenuItemId(s.id).map(a=>{const i=I.getById(a.inventoryProductId);return{...a,stockItem:i}});t.json({...s,ingredients:o})}else t.status(404).json({error:"MenuItem not found."})}catch(e){t.status(500).json({error:"Failed to fetch menu item. "+e.message})}}),j.post("/menu-items",(r,t)=>{try{const e=new w(r.body),s=e.save();r.body.ingredients.forEach(i=>{new y({menuItemId:s,inventoryProductId:i.inventoryProductId,quantityUsed:i.quantityUsed}).save()});const a=y.getByMenuItemId(e.id).map(i=>{const d=I.getById(i.inventoryProductId);return{...i,stockItem:d}});t.status(201).json({...e,ingredients:a})}catch(e){t.status(500).json({error:"Failed to create menu item. "+e.message})}}),j.put("/menu-items/:id",(r,t)=>{const e=r.params.id,{name:s,quantity:n,unit:o,isActive:a,categoryId:i,printLocations:d,variablePrice:u,price:l,ingredients:p}=r.body;let m=w.getById(e);if(!m)return t.status(404).json({error:"Menu item not found"});m.name=s,m.quantity=n,m.unit=o,m.isActive=a,m.categoryId=i,m.printLocations=d,m.variablePrice=u,m.price=l,m.save(),y.deleteByMenuItemId(e),p.forEach(k=>{new y({menuItemId:e,inventoryProductId:k.inventoryProductId,quantityUsed:k.quantityUsed}).save()});const O=y.getByMenuItemId(e).map(k=>{const V=I.getById(k.inventoryProductId);return{...k,stockItem:V}});t.json({...m,ingredients:O})}),j.delete("/menu-items/:id",(r,t)=>{try{const{id:e}=r.params,s=w.getById(Number(e));s?(s.delete(),t.json({message:"MenuItem deleted successfully."})):t.status(404).json({error:"MenuItem not found."})}catch(e){t.status(500).json({error:"Failed to delete menu item. "+e.message})}}),j.get("/ingredients",(r,t)=>{try{const e=y.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch ingredients. "+e.message})}}),j.get("/ingredients/menu-item/:menuItemId",(r,t)=>{try{const{menuItemId:e}=r.params,s=y.getByMenuItemId(Number(e));t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch ingredients. "+e.message})}}),j.post("/ingredients",(r,t)=>{try{const e=new y(r.body);if(!w.getById(e.menuItemId))return t.status(404).json({error:"MenuItem not found."});if(!I.getById(e.inventoryProductId))return t.status(404).json({error:"Inventory product not found."});const o=e.save();t.status(201).json({id:o})}catch(e){t.status(500).json({error:"Failed to create ingredient. "+e.message})}}),j.put("/ingredients/:id",(r,t)=>{try{const{id:e}=r.params,s=y.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"Ingredient updated successfully."})):t.status(404).json({error:"Ingredient not found."})}catch(e){t.status(500).json({error:"Failed to update ingredient. "+e.message})}}),j.delete("/ingredients/:id",(r,t)=>{try{const{id:e}=r.params,s=y.getById(Number(e));s?(s.delete(),t.json({message:"Ingredient deleted successfully."})):t.status(404).json({error:"Ingredient not found."})}catch(e){t.status(500).json({error:"Failed to delete ingredient. "+e.message})}}),j.get("/stock-items",(r,t)=>{try{const e=I.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch stock items. "+e.message})}}),j.get("/stock-items/:id",(r,t)=>{try{const{id:e}=r.params,s=I.getById(Number(e));s?t.json(s):t.status(404).json({error:"StockItem not found."})}catch(e){t.status(500).json({error:"Failed to fetch stock item. "+e.message})}}),j.post("/stock-items",(r,t)=>{try{const s=new I(r.body).save();t.status(201).json({id:s})}catch(e){t.status(500).json({error:"Failed to create stock item. "+e.message})}}),j.put("/stock-items/:id",(r,t)=>{try{const{id:e}=r.params,s=I.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"StockItem updated successfully."})):t.status(404).json({error:"StockItem not found."})}catch(e){t.status(500).json({error:"Failed to update stock item. "+e.message})}}),j.delete("/stock-items/:id",(r,t)=>{try{const{id:e}=r.params,s=I.getById(Number(e));s?(s.delete(),t.json({message:"StockItem deleted successfully."})):t.status(404).json({error:"StockItem not found."})}catch(e){t.status(500).json({error:"Failed to delete stock item. "+e.message})}});class E{static{g(this,"RecurrentDate")}static tableName="RecurrentDate";constructor({id:t,promoId:e,dayOfWeek:s,startTime:n,endTime:o}){this.id=t||null,this.promoId=e,this.dayOfWeek=s,this.startTime=n,this.endTime=o}static getAll(){return c.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new E(s))}static getById(t){const s=c.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new E(s):null}static getByPromoId(t){return c.prepare(`SELECT * FROM ${this.tableName} WHERE promoId = ?`).all(t).map(n=>new E(n))}isNowWithinRule(){const t=new Date,e=t.getDay(),n=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"][e];if(this.dayOfWeek!==n)return!1;const[o,a]=this.startTime.split(":").map(Number),[i,d]=this.endTime.split(":").map(Number),u=new Date(t);u.setHours(o,a,0,0);const l=new Date(t);return l.setHours(i,d,0,0),l<=u&&l.setDate(l.getDate()+1),t>=u&&t<=l}isTimeWithinRule(t){const e=t.getDay(),n=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"][e];if(this.dayOfWeek!==n)return!1;const[o,a]=this.startTime.split(":").map(Number),[i,d]=this.endTime.split(":").map(Number),u=new Date(t);u.setHours(o,a,0,0);const l=new Date(t);return l.setHours(i,d,0,0),l<=u&&l.setDate(l.getDate()+1),t>=u&&t<=l}save(){if(this.id)return c.prepare(`UPDATE ${E.tableName}
                SET promoId = ?, dayOfWeek = ?, startTime = ?, endTime = ?
                WHERE id = ?`).run(this.promoId,this.dayOfWeek,this.startTime,this.endTime,this.id).changes>0;{const e=c.prepare(`INSERT INTO ${E.tableName} (promoId, dayOfWeek, startTime, endTime)
                VALUES (?, ?, ?, ?)`).run(this.promoId,this.dayOfWeek,this.startTime,this.endTime);return this.id=e.lastInsertRowid,this.id}}delete(){if(!this.id)throw new Error("Cannot delete an unsaved RecurrentDate.");return c.prepare(`DELETE FROM ${E.tableName} WHERE id = ?`).run(this.id).changes>0}}class f{static{g(this,"Promo")}static tableName="Promo";constructor({id:t,menuItemId:e,startDate:s,endDate:n,type:o,discount:a,buy_quantity:i,pay_quantity:d,percentage:u,always:l,isActive:p,name:m}){this.id=t||null,this.menuItemId=e,this.startDate=s,this.endDate=n,this.type=o,this.discount=a||null,this.buy_quantity=i||null,this.pay_quantity=d||null,this.percentage=u||null,this.always=!!l||!1,this.isActive=!!p,this.name=m}static getAll(){return c.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new f(s))}static getById(t){const s=c.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new f(s):null}static getActiveByMenuItemId(t){return c.prepare(`SELECT * FROM ${this.tableName} WHERE menuItemId = ? AND isActive = 1`).all(t).map(a=>new f(a)).filter(a=>a.isCurrentlyActive())}static getByMenuItemId(t){const s=c.prepare(`SELECT * FROM ${this.tableName} WHERE menuItemId = ?`).get(t);return s?new f(s):null}isCurrentlyActive(){const t=new Date;return this.always?!0:this.startDate&&t<new Date(this.startDate)||this.endDate&&t>new Date(this.endDate)?!1:this.getRecurrenceRules().some(s=>s.isNowWithinRule())}isValidAtTimestamp(t){const e=new Date(t);return this.always?!0:this.startDate&&e<new Date(this.startDate)||this.endDate&&e>new Date(this.endDate)?!1:this.getRecurrenceRules().some(n=>n.isTimeWithinRule(e))}calculateDiscount(t,e,s){let n=0;if(this.type==="percentage_discount")n=e*(this.percentage/100);else if(this.type==="buy_x_get_y"){const o=this.buy_quantity-this.pay_quantity;n=Math.floor(t/this.buy_quantity)*o*s}else this.type==="price_discount"&&(n=this.discount*t);return n}getRecurrenceRules(){if(!this.id)throw new Error("Cannot fetch recurrence rules for an unsaved Promo.");return E.getByPromoId(this.id)}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=c.prepare(`INSERT INTO ${f.tableName} (menuItemId, startDate, endDate, type, discount, buy_quantity, pay_quantity, percentage, always, isActive, name)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(this.menuItemId,this.startDate,this.endDate,this.type,this.discount,this.buy_quantity,this.pay_quantity,this.percentage,this.always?1:0,this.isActive?1:0,this.name);return this.id=e.lastInsertRowid,this.id}#e(){return c.prepare(`UPDATE ${f.tableName}
            SET menuItemId = ?, startDate = ?, endDate = ?, type = ?, discount = ?, buy_quantity = ?, pay_quantity = ?, percentage = ?, always = ?, isActive = ?, name = ?
            WHERE id = ?`).run(this.menuItemId,this.startDate,this.endDate,this.type,this.discount,this.buy_quantity,this.pay_quantity,this.percentage,this.always?1:0,this.isActive?1:0,this.name,this.id).changes>0}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Promo.");return E.getByPromoId(this.id).forEach(n=>n.delete()),c.prepare(`DELETE FROM ${f.tableName} WHERE id = ?`).run(this.id).changes>0}}class R{static{g(this,"OrderItem")}static tableName="OrderItem";constructor({id:t,menuItemId:e,orderId:s,promoId:n,quantity:o,subtotal:a,discountApplied:i,total:d,promoName:u,comments:l,quantityHistory:p="[]",appliedPromos:m="[]"}){this.id=t||null,this.menuItemId=e,this.orderId=s,this.promoId=n||null,this.quantity=o,this.subtotal=a,this.discountApplied=i||0,this.total=d||a-this.discountApplied,this.promoName=u||null,this.comments=l||null,this.quantityHistory=JSON.parse(p),this.appliedPromos=JSON.parse(m)}static getAll(){return c.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new R(s))}static getById(t){const s=c.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new R(s):null}static getByOrderId(t){return c.prepare(`SELECT * FROM ${this.tableName} WHERE orderId = ?`).all(t).map(n=>new R(n))}async addQuantity(t,e=new Date().toISOString()){this.quantity+t>=0&&this.quantityHistory.push({quantity:t,timestamp:e}),this.quantity+=t,this.quantity<0&&(this.quantity=0);const s=await w.getById(this.menuItemId);this.subtotal=s.price*this.quantity;const n=await f.getActiveByMenuItemId(this.menuItemId);return console.log("active promos",n.length),this.calculatePromotions(e,n),this.updateTotals(),this.save()}calculatePromotions(t,e){const s=[...this.quantityHistory].sort((n,o)=>new Date(n.timestamp)-new Date(o.timestamp));e.forEach(n=>{let o=0;if(s.forEach(a=>{a.promoActive=!1,n.isValidAtTimestamp(a.timestamp)&&(o+=a.quantity)}),o>0){const a=n.calculateDiscount(o,o*this.getBasePrice(),this.getBasePrice());a>0?this.appliedPromos.push({promoId:n.id,promoName:n.name,quantity:o,discountApplied:a,timestamp:t,type:n.type}):this.appliedPromos=this.appliedPromos.filter(i=>i.promoId!==n.id)}})}getBasePrice(){return w.getById(this.menuItemId).price}updateTotals(){console.log("applied promos",this.appliedPromos),this.discountApplied=this.appliedPromos.at(-1)?.discountApplied||0,this.discountApplied=Math.min(this.discountApplied,this.subtotal),this.total=this.subtotal-this.discountApplied}save(){if(this.id)return this.#e();{const t=w.getById(this.menuItemId);return this.subtotal||(this.subtotal=t.price*this.quantity),this.#t()}}#t(){const e=c.prepare(`INSERT INTO ${R.tableName} (menuItemId, orderId, promoId, quantity, subtotal, discountApplied, total, promoName, comments)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(this.menuItemId,this.orderId,this.promoId,this.quantity,this.subtotal,this.discountApplied,this.total,this.promoName,this.comments);return this.id=e.lastInsertRowid,this.id}#e(){return c.prepare(`UPDATE ${R.tableName}
            SET menuItemId = ?, orderId = ?, promoId = ?, quantity = ?, subtotal = ?, discountApplied = ?, total = ?, promoName = ?, comments = ?, quantityHistory = ?, appliedPromos = ?
            WHERE id = ?`).run(this.menuItemId,this.orderId,this.promoId,this.quantity,this.subtotal,this.discountApplied,this.total,this.promoName,this.comments,JSON.stringify(this.quantityHistory),JSON.stringify(this.appliedPromos),this.id).changes>0}delete(){if(!this.id)throw new Error("Cannot delete an unsaved OrderItem.");return c.prepare(`DELETE FROM ${R.tableName} WHERE id = ?`).run(this.id).changes>0}}class h{static{g(this,"Order")}static tableName='"Order"';constructor({id:t,customer:e,subtotal:s,discountTotal:n,total:o,tip:a,createdAt:i,paymentMethod:d,cancelledAt:u,cancelReason:l,status:p,claimedById:m,billedById:T,billedAt:O}){this.id=t||null,this.customer=e,this.subtotal=s||0,this.discountTotal=n||0,this.total=o||0,this.tip=a||0,this.createdAt=i||null,this.paymentMethod=d||null,this.cancelledAt=u||null,this.cancelReason=l||null,this.status=p||"active",this.claimedById=m||null,this.billedById=T||null,this.billedAt=O||null}static getAll(){return c.prepare(`SELECT * FROM ${this.tableName}`).all().map(s=>new h(s))}static getByStatus(t){return c.prepare(`SELECT * FROM ${this.tableName} WHERE status = ?`).all(t).map(n=>new h(n))}static getActiveByClaimedId(t){return c.prepare(`SELECT * FROM ${this.tableName} WHERE claimedById = ? AND status = 'active'`).all(t).map(n=>new h(n))}static getById(t){const s=c.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new h(s):null}static getByCustomer(t){return c.prepare(`SELECT * FROM ${this.tableName} WHERE customer = ?`).all(t).map(n=>new h(n))}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=c.prepare(`INSERT INTO ${h.tableName} (customer, subtotal, discountTotal, total, tip, paymentMethod, status, claimedById, billedById, billedAt, createdAt)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)`).run(this.customer,this.subtotal,this.discountTotal,this.total,this.tip,this.paymentMethod,this.status,this.claimedById,this.billedById,this.billedAt,this.createdAt);return this.id=e.lastInsertRowid,this.id}#e(){return c.prepare(`UPDATE ${h.tableName}
            SET customer = ?, subtotal = ?, discountTotal = ?, total = ?, tip = ?, paymentMethod = ?, cancelledAt = ?, cancelReason = ?, status = ?, claimedById = ?, billedById = ?, billedAt = ?, createdAt = ?
            WHERE id = ?`).run(this.customer,this.subtotal,this.discountTotal,this.total,this.tip,this.paymentMethod,this.cancelledAt,this.cancelReason,this.status,this.claimedById,this.billedById,this.billedAt,this.createdAt,this.id).changes>0}getEnhancedOrder(){const t=R.getByOrderId(this.id);let e=0,s=0;t.forEach(o=>{e+=o.subtotal,s+=o.discountApplied});const n=e-s<0?0:e-s;return{...this,orderItems:t,subtotal:e,discountTotal:s,total:n}}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Order.");return c.prepare(`DELETE FROM ${h.tableName} WHERE id = ?`).run(this.id).changes>0}}const v=D();v.get("/",(r,t)=>{try{const s=h.getAll().map(n=>{const o=R.getByOrderId(n.id);let a=0,i=0;o.forEach(u=>{a+=u.subtotal,i+=u.discountApplied});const d=a-i<0?0:a-i;return n.subtotal=a,n.discountTotal=i,n.total=d,{...n,orderItems:o,subtotal:a,discountTotal:i}});t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch orders. "+e.message})}}),v.get("/active",(r,t)=>{try{const s=h.getByStatus("active").map(n=>{const o=R.getByOrderId(n.id);let a=0,i=0;o.forEach(u=>{a+=u.subtotal,i+=u.discountApplied});const d=a-i<0?0:a-i;return n.subtotal=a,n.discountTotal=i,n.total=d,{...n,orderItems:o,subtotal:a,discountTotal:i}});t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch orders. "+e.message})}}),v.get("/active-orders-by-agent/:agentId",(r,t)=>{try{const{agentId:e}=r.params,n=h.getActiveByClaimedId(e).map(o=>o.getEnhancedOrder());t.json(n)}catch(e){t.status(500).json({error:"Failed to fetch orders. "+e.message})}}),v.get("/:id",(r,t)=>{const e=r.params.id,s=h.getById(e);if(!s)return t.status(404).json({message:"Order not found"});const n=R.getByOrderId(e);let o=0,a=0;n.forEach(d=>{o+=d.subtotal,a+=d.discountApplied});const i=o-a<0?0:o-a;s.subtotal=o,s.discountTotal=a,s.total=i,t.json({...s,orderItems:n})}),v.post("/",(r,t)=>{try{const e=new h(r.body);e.createdAt=new Date().toISOString(),e.save(),t.status(201).json(e)}catch(e){t.status(500).json({error:"Failed to create order. "+e.message})}}),v.put("/:id",(r,t)=>{try{const{id:e}=r.params,s=h.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"Order updated successfully."})):t.status(404).json({error:"Order not found."})}catch(e){t.status(500).json({error:"Failed to update order. "+e.message})}}),v.delete("/:id",(r,t)=>{try{const{id:e}=r.params,s=h.getById(Number(e));s?(s.delete(),t.json({message:"Order deleted successfully."})):t.status(404).json({error:"Order not found."})}catch(e){t.status(500).json({error:"Failed to delete order. "+e.message})}}),v.get("/:orderId/order-items",(r,t)=>{try{const{orderId:e}=r.params,s=R.getByOrderId(Number(e));t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch order items. "+e.message})}}),v.put("/:id/charge",async(r,t)=>{try{const{id:e}=r.params,{tip:s,paymentMethod:n,billedById:o}=r.body,a=h.getById(Number(e));if(!a)return t.status(404).json({message:"Order not found"});a.tip=s,a.paymentMethod=n,a.status="paid",a.billedById=o,a.billedAt=new Date().toISOString(),a.save(),t.json({message:"Order charged successfully."})}catch(e){t.status(500).json({error:"Failed to charge order. "+e.message})}}),v.put("/:id/cancel",async(r,t)=>{try{const{id:e}=r.params,{cancelReason:s}=r.body,n=h.getById(Number(e));if(!n)return t.status(404).json({message:"Order not found"});n.status="cancelled",n.cancelledAt=new Date().toISOString(),n.cancelReason=s,n.save(),R.getByOrderId(Number(e)).forEach(a=>{const i=y.getByMenuItemId(a.menuItemId);for(const d of i){const u=I.getById(d.inventoryProductId);u.stock+=d.quantityUsed*a.quantity,u.save()}a.delete()}),t.status(200).json({message:"Order cancelled successfully",order:n})}catch(e){console.log(e),t.status(500).json({message:"Server error",error:e})}}),v.put("/:id/unpay",async(r,t)=>{try{const{id:e}=r.params,s=h.getById(Number(e));if(!s)return t.status(404).json({message:"Order not found"});s.status="unpaid",s.billedById=null,s.billedAt=null,s.save(),t.json({message:"Order status updated successfully."})}catch(e){t.status(500).json({error:"Failed to update order status. "+e.message})}}),v.patch("/:id/tip",(r,t)=>{try{const{id:e}=r.params,{tip:s}=r.body;if(s===void 0)return t.status(400).json({error:"Tip amount is required"});const n=h.getById(Number(e));if(!n)return t.status(404).json({message:"Order not found"});n.tip+=s,n.save();const o=n.getEnhancedOrder();t.json({message:"Tip added successfully",order:o})}catch(e){t.status(500).json({error:"Failed to add tip. "+e.message})}});const b=D();b.get("/",(r,t)=>{try{const e=f.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch promotions. "+e.message})}}),b.post("/promos-with-availability",(r,t)=>{try{const{availability:e,...s}=r.body;if(!["price_discount","percentage_discount","buy_x_get_y"].includes(s.type))return t.status(400).json({error:"Invalid promo type. Must be 'discount' or 'buy_x_get_y'."});s.startDate=s.startDate?new Date(s.startDate).toISOString():null,s.endDate=s.endDate?new Date(s.endDate).toISOString():null,s.buy_quantity=s.buy_quantity??null,s.pay_quantity=s.pay_quantity??null,s.price_discount=s.discount??null,s.percentage_discount=s.percentage??null;const n=new f(s);n.save();const o=n.id;e&&Object.entries(e).forEach(([i,d])=>{d&&d.startTime&&d.endTime&&new E({promoId:o,dayOfWeek:i.charAt(0).toUpperCase()+i.slice(1),startTime:d.startTime,endTime:d.endTime}).save()}),t.status(201).json({id:o,message:"Promo and availability created successfully."})}catch(e){console.error(e),t.status(500).json({error:`Failed to create promo and availability. ${e.message}`})}}),b.put("/promos-with-availability/:id",async(r,t)=>{try{const e=r.params.id,{availability:s,...n}=r.body,o=f.getById(e);if(!o)return t.status(404).json({error:"Promo not found."});Object.assign(o,n),o.save(),s&&(o.getRecurrenceRules().forEach(i=>i.delete()),Object.entries(s).forEach(([i,d])=>{d&&d.startTime&&d.endTime&&new E({promoId:o.id,dayOfWeek:i.charAt(0).toUpperCase()+i.slice(1),startTime:d.startTime,endTime:d.endTime}).save()})),t.status(200).json({id:o.id,message:"Promo and availability updated successfully."})}catch(e){console.error(e),t.status(500).json({error:`Failed to update promo and availability. ${e.message}`})}}),b.delete("/promos-with-availability/:id",async(r,t)=>{try{const e=r.params.id,s=f.getById(e);if(!s)return t.status(404).json({error:"Promo not found."});if(!s.delete())return t.status(500).json({error:"Failed to delete the promo."});t.status(200).json({message:"Promo and its availability successfully deleted."})}catch(e){console.error("Error in DELETE promo:",e),t.status(500).json({error:`Failed to delete promo and its availability. ${e.message}`})}}),b.get("/promos-with-availability",(r,t)=>{try{const s=f.getAll().map(n=>{const o=E.getByPromoId(n.id),a={Monday:{startTime:null,endTime:null},Tuesday:{startTime:null,endTime:null},Wednesday:{startTime:null,endTime:null},Thursday:{startTime:null,endTime:null},Friday:{startTime:null,endTime:null},Saturday:{startTime:null,endTime:null},Sunday:{startTime:null,endTime:null}};return o.forEach(i=>{a[i.dayOfWeek]={startTime:i.startTime,endTime:i.endTime}}),{...n,availability:a}});t.json(s)}catch(e){console.error(e),t.status(500).json({error:"Failed to fetch promotions with availability."})}}),b.get("/:id",(r,t)=>{try{const{id:e}=r.params,s=f.getById(Number(e));s?t.json(s):t.status(404).json({error:"Promotion not found."})}catch(e){t.status(500).json({error:"Failed to fetch promotion. "+e.message})}}),b.post("/",(r,t)=>{try{const s=new f(r.body).save();t.status(201).json({id:s})}catch(e){t.status(500).json({error:"Failed to create promotion. "+e.message})}}),b.put("/:id",(r,t)=>{try{const{id:e}=r.params,s=f.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"Promotion updated successfully."})):t.status(404).json({error:"Promotion not found."})}catch(e){t.status(500).json({error:"Failed to update promotion. "+e.message})}}),b.delete("/:id",(r,t)=>{try{const{id:e}=r.params,s=f.getById(Number(e));s?(s.delete(),t.json({message:"Promotion deleted successfully."})):t.status(404).json({error:"Promotion not found."})}catch(e){t.status(500).json({error:"Failed to delete promotion. "+e.message})}}),b.get("/:id/recurrence-rules",(r,t)=>{try{const{id:e}=r.params,s=f.getById(Number(e));if(s){const n=s.getRecurrenceRules();t.json(n)}else t.status(404).json({error:"Promotion not found."})}catch(e){t.status(500).json({error:"Failed to fetch recurrence rules. "+e.message})}}),b.post("/:id/recurrence-rules",(r,t)=>{try{const{id:e}=r.params;if(f.getById(Number(e))){const o=new E({...r.body,promoId:Number(e)}).save();t.status(201).json({recurrenceId:o})}else t.status(404).json({error:"Promotion not found."})}catch(e){t.status(500).json({error:"Failed to create recurrence rule. "+e.message})}}),b.put("/recurrence-rules/:id",(r,t)=>{try{const{id:e}=r.params,s=E.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"Recurrence rule updated successfully."})):t.status(404).json({error:"Recurrence rule not found."})}catch(e){t.status(500).json({error:"Failed to update recurrence rule. "+e.message})}}),b.delete("/promos/recurrence-rules/:id",(r,t)=>{try{const{id:e}=r.params,s=E.getById(Number(e));s?(s.delete(),t.json({message:"Recurrence rule deleted successfully."})):t.status(404).json({error:"Recurrence rule not found."})}catch(e){t.status(500).json({error:"Failed to delete recurrence rule. "+e.message})}}),b.get("/recurrent-dates",(r,t)=>{try{const e=E.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch recurrent dates. "+e.message})}}),b.get("/recurrent-dates/promo/:promoId",(r,t)=>{try{const{promoId:e}=r.params,s=E.getByPromoId(Number(e));t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch recurrent dates for promo. "+e.message})}}),b.post("/recurrent-dates",(r,t)=>{try{const s=new E(r.body).save();t.status(201).json({id:s})}catch(e){t.status(500).json({error:"Failed to create recurrent date. "+e.message})}}),b.put("/recurrent-dates/:id",(r,t)=>{try{const{id:e}=r.params,s=E.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"RecurrentDate updated successfully."})):t.status(404).json({error:"RecurrentDate not found."})}catch(e){t.status(500).json({error:"Failed to update recurrent date. "+e.message})}}),b.delete("/recurrent-dates/:id",(r,t)=>{try{const{id:e}=r.params,s=E.getById(Number(e));s?(s.delete(),t.json({message:"RecurrentDate deleted successfully."})):t.status(404).json({error:"RecurrentDate not found."})}catch(e){t.status(500).json({error:"Failed to delete recurrent date. "+e.message})}});class A{static{g(this,"Category")}static tableName="Category";constructor({id:t,name:e,description:s,type:n}){this.id=t||null,this.name=e,this.description=s,this.type=n}static getAll(){return c.prepare(`SELECT * FROM ${this.tableName} ORDER BY name ASC`).all().map(s=>new A(s))}static getById(t){const s=c.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new A(s):null}static getAllByType(t){return c.prepare(`SELECT * FROM ${this.tableName} WHERE type = ? ORDER BY name ASC`).all(t).map(n=>new A(n))}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=c.prepare(`INSERT INTO ${A.tableName} (name, description, type)
            VALUES (?, ?, ?)`).run(this.name,this.description,this.type);return this.id=e.lastInsertRowid,this.id}#e(){return c.prepare(`UPDATE ${A.tableName}
            SET name = ?, description = ?, type = ?
            WHERE id = ?`).run(this.name,this.description,this.type,this.id).changes}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Category.");return c.prepare(`DELETE FROM ${A.tableName} WHERE id = ?`).run(this.id).changes>0}}const C=D();C.get("/",(r,t)=>{try{const{type:e}=r.query;let s;e?s=A.getAllByType(e):s=A.getAll(),t.json(s)}catch(e){t.status(500).json({error:"Failed to fetch categories. "+e.message})}}),C.get("/:id",(r,t)=>{try{const{id:e}=r.params,s=A.getById(Number(e));s?t.json(s):t.status(404).json({error:"Category not found."})}catch(e){t.status(500).json({error:"Failed to fetch category. "+e.message})}}),C.post("/",(r,t)=>{try{const s=new A(r.body).save();t.status(201).json({id:s})}catch(e){t.status(500).json({error:"Failed to create category. "+e.message})}}),C.put("/:id",(r,t)=>{try{const{id:e}=r.params,s=A.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"Category updated successfully."})):t.status(404).json({error:"Category not found."})}catch(e){t.status(500).json({error:"Failed to update category. "+e.message})}}),C.delete("/:id",(r,t)=>{try{const{id:e}=r.params,s=A.getById(Number(e));s?(s.delete(),t.json({message:"Category deleted successfully."})):t.status(404).json({error:"Category not found."})}catch(e){console.log(e),t.status(500).json({error:"Failed to delete category. "+e.message})}});class S{static{g(this,"Supplier")}static tableName="Supplier";constructor({id:t,name:e,phone:s,email:n,address:o}){this.id=t||null,this.name=e,this.phone=s||null,this.email=n||null,this.address=o||null}static getAll(){return c.prepare(`SELECT * FROM ${this.tableName} ORDER BY name ASC`).all().map(s=>new S(s))}static getById(t){const s=c.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new S(s):null}save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=c.prepare(`INSERT INTO ${S.tableName} (name, phone, email, address)
            VALUES (?, ?, ?, ?)`).run(this.name,this.phone,this.email,this.address);return this.id=e.lastInsertRowid,this.id}#e(){return c.prepare(`UPDATE ${S.tableName}
            SET name = ?, phone = ?, email = ?, address = ?
            WHERE id = ?`).run(this.name,this.phone,this.email,this.address,this.id).changes}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Supplier.");return c.prepare(`DELETE FROM ${S.tableName} WHERE id = ?`).run(this.id).changes>0}}const L=D();L.get("/",(r,t)=>{try{const e=S.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch suppliers. "+e.message})}}),L.get("/:id",(r,t)=>{try{const{id:e}=r.params,s=S.getById(Number(e));s?t.json(s):t.status(404).json({error:"Supplier not found."})}catch(e){t.status(500).json({error:"Failed to fetch supplier. "+e.message})}}),L.post("/",(r,t)=>{try{const s=new S(r.body).save();t.status(201).json({id:s})}catch(e){t.status(500).json({error:"Failed to create supplier. "+e.message})}}),L.put("/:id",(r,t)=>{try{const{id:e}=r.params,s=S.getById(Number(e));s?(Object.assign(s,r.body),s.save(),t.json({message:"Supplier updated successfully."})):t.status(404).json({error:"Supplier not found."})}catch(e){t.status(500).json({error:"Failed to update supplier. "+e.message})}}),L.delete("/:id",(r,t)=>{try{const{id:e}=r.params,s=S.getById(Number(e));s?(s.delete(),t.json({message:"Supplier deleted successfully."})):t.status(404).json({error:"Supplier not found."})}catch(e){t.status(500).json({error:"Failed to delete supplier. "+e.message})}});class B{static{g(this,"Agent")}static tableName="Agent";constructor({id:t,name:e,lastName:s,image:n,address:o,phone:a,rfc:i,email:d,pin:u,role:l,isActive:p}){this.id=t||null,this.name=e,this.lastName=s,this.image=n||null,this.address=o,this.phone=a,this.rfc=i,this.email=d,this.pin=u,this.role=l,this.isActive=p!==void 0?p:1}static getAll(){return c.prepare(`SELECT id, name, lastName, email, role, isActive FROM ${this.tableName} ORDER BY name ASC`).all().map(s=>new B(s))}static getById(t){const s=c.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`).get(t);return s?new B(s):null}static getByEmail(t){const s=c.prepare(`SELECT * FROM ${this.tableName} WHERE email = ?`).get(t);return s?new B(s):null}async save(){return this.id?this.#e():(this.id=this.#t(),this.id)}#t(){const e=c.prepare(`INSERT INTO ${B.tableName} (name, lastName, image, address, phone, rfc, email, pin, role, isActive)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(this.name,this.lastName,this.image,this.address,this.phone,this.rfc,this.email,this.pin,this.role,this.isActive);return this.id=e.lastInsertRowid,this.id}#e(){return c.prepare(`UPDATE ${B.tableName}
            SET name = ?, lastName = ?, image = ?, address = ?, phone = ?, rfc = ?, email = ?, pin = ?, role = ?, isActive = ?
            WHERE id = ?`).run(this.name,this.lastName,this.image,this.address,this.phone,this.rfc,this.email,this.pin,this.role,this.isActive,this.id).changes}delete(){if(!this.id)throw new Error("Cannot delete an unsaved Agent.");return c.prepare(`DELETE FROM ${B.tableName} WHERE id = ?`).run(this.id).changes>0}static async authenticate(t,e){const s=this.getByEmail(t);return!s||s.pin!==e?null:s}}_.config();const X=process.env.JWT_SECRET_KEY,ot=g((r,t="24h")=>{try{return J.sign(r,X,{expiresIn:t})}catch(e){throw new Error(`Error generating token: ${e.message}`)}},"generateToken"),at=g(r=>{try{return J.verify(r,X)}catch{throw new Error("Invalid or expired token.")}},"verifyToken"),it=g((r,t,e,s,n)=>({role:r,email:t,name:e,lastName:s,id:n}),"generateJwtPayload"),ct=g((r,t,e)=>{try{const s=r.headers.authorization;if(!s||!s.startsWith("Bearer "))return t.status(401).json({message:"Unauthorized: No token provided"});const n=s.split(" ")[1],o=at(n);r.user=o,e()}catch{t.status(401).json({message:"Unauthorized: Invalid or expired token"})}},"authenticate"),H=D();H.post("/",async(r,t)=>{const{email:e,pin:s}=r.body;if(!e||!s)return t.status(400).json({status:"error",message:"Missing required fields: email, pin are required."});try{let n=await B.authenticate(e,s);if(!n||n.length===0)return t.status(404).json({message:"Credenciales inv\xE1lidas"});let o=it(n.role,n.email,n.name,n.lastName,n.id),a=ot(o,"24h");t.status(200).json({token:a})}catch(n){console.log(n),t.status(500).json({error:n.message})}}),H.get("/",ct,async(r,t)=>{try{t.status(200).json({message:"valid"})}catch(e){t.status(500).json({error:e.message})}});const q=D();q.get("/",(r,t)=>{try{const e=R.getAll();t.json(e)}catch(e){t.status(500).json({error:"Failed to fetch order items. "+e.message})}}),q.post("/",async(r,t)=>{try{const{menuItemId:e,orderId:s,quantity:n,comments:o}=r.body,a=new Date().toISOString();if(!w.getById(e))return t.status(400).json({error:"El MenuItem proporcionado no existe."});const d=new R({menuItemId:e,orderId:s,quantity:0,subtotal:0,comments:o,quantityHistory:"[]",appliedPromos:"[]"}),u=y.getByMenuItemId(d.menuItemId),l=[];for(const T of u){const O=I.getById(T.inventoryProductId);if(O.stock-T.quantityUsed*n<0){l.push({...O,required:T.quantityUsed*n});continue}O.stock-=T.quantityUsed*n,O.save()}if(l.length>0)return t.status(400).json({error:"No hay suficientes insumos para agregar esto",notEnoughStock:l});await d.save(),await d.addQuantity(n,a);const m=h.getById(s).getEnhancedOrder();t.status(201).json({orderItem:d,order:m})}catch(e){console.error("Error creating OrderItem:",e),t.status(500).json({error:e.message})}}),q.put("/:id/quantity",async(r,t)=>{const{id:e}=r.params,{quantity:s,timestamp:n,comments:o}=r.body;try{const a=await R.getById(e);if(!a)return t.status(404).json({error:"OrderItem not found"});if(a.quantity+s<0)return t.status(400).json({error:"No se puede reducir m\xE1s la cantidad de el item"});const i=y.getByMenuItemId(a.menuItemId),d=[];for(const p of i){const m=I.getById(p.inventoryProductId);if(m.stock-p.quantityUsed*s<0){d.push({...m,required:p.quantityUsed*s});continue}m.stock-=p.quantityUsed*s,m.save()}if(d.length>0)return t.status(400).json({error:"No hay suficientes insumos para agregar esto",notEnoughStock:d});o&&(a.comments=o),await a.save(),await a.addQuantity(s,n);const l=h.getById(a.orderId).getEnhancedOrder();t.json({orderItem:a,order:l})}catch(a){t.status(500).json({error:a.message})}}),q.delete("/:id",async(r,t)=>{const{id:e}=r.params;try{const s=await R.getById(e);if(!s)return t.status(404).json({error:"OrderItem not found"});const n=h.getById(s.orderId),o=y.getByMenuItemId(s.menuItemId);for(const i of o){const d=I.getById(i.inventoryProductId);d.stock+=i.quantityUsed*s.quantity,d.save()}await s.delete();const a=n.getEnhancedOrder();t.json(a)}catch(s){console.error("Error deleting OrderItem:",s),t.status(500).json({error:s.message})}});const U=D(),dt=F.resolve(),Y=F.join(dt,"config.json"),ut=g(()=>{const r=P.readFileSync(Y,"utf8");return JSON.parse(r)},"readConfig"),lt=g(r=>{P.writeFileSync(Y,JSON.stringify(r,null,2),"utf8")},"writeConfig");U.get("/",(r,t)=>{try{const e=ut();t.json(e)}catch{t.status(500).json({error:"Error al leer la configuraci\xF3n"})}}),U.put("/",(r,t)=>{try{const e=r.body;lt(e),t.json({message:"Configuraci\xF3n actualizada correctamente"})}catch{t.status(500).json({error:"Error al actualizar la configuraci\xF3n"})}});const mt=g(()=>{const r=g(t=>c.prepare(`SELECT COUNT(*) as count FROM ${t}`).get().count===0,"isTableEmpty");if(r("Category")){console.log("Seed data: Adding initial categories...");const t=[{id:1,name:"Entradas",description:"Categor\xEDa para entradas del men\xFA",type:"menu"},{id:2,name:"Bebidas",description:"Categor\xEDa para bebidas del men\xFA",type:"menu"},{id:3,name:"Ingredientes",description:"Categor\xEDa para ingredientes de cocina",type:"stock"},{id:4,name:"Limpieza",description:"Categor\xEDa para productos de limpieza",type:"stock"},{id:-1,name:"Sin clasificar",description:"Categor\xEDa para productos sin clasificar",type:"stock"},{id:-2,name:"Sin clasificar",description:"Categor\xEDa para productos sin clasificar",type:"menu"}],e=c.prepare(`
      INSERT INTO Category (id, name, description, type) VALUES (?, ?, ?, ?)
    `);t.forEach(s=>{e.run(s.id,s.name,s.description,s.type)}),console.log("Categories seeded.")}if(r("Supplier")){console.log("Seed data: Adding initial suppliers...");const t=[{name:"Distribuidora Alimentos",phone:"555-123-4567",email:"ventas@alimentos.com",address:"Calle 1, Ciudad A"},{name:"Bebidas Premium",phone:"555-987-6543",email:"contacto@bebidas.com",address:"Avenida B, Ciudad B"},{name:"Productos Limpieza",phone:"555-654-3210",email:"soporte@limpieza.com",address:"Calle C, Ciudad C"}],e=c.prepare(`
      INSERT INTO Supplier (name, phone, email, address) VALUES (?, ?, ?, ?)
    `);t.forEach(s=>{e.run(s.name,s.phone,s.email,s.address)}),console.log("Suppliers seeded.")}if(r("StockItem")){console.log("Seed data: Adding initial stock items...");const t=[{name:"Harina",stock:50,unit:"kg",isActive:!0,categoryId:3,supplierId:1,cost:12.5},{name:"Az\xFAcar",stock:30,unit:"kg",isActive:!0,categoryId:3,supplierId:1,cost:10},{name:"Leche",stock:100,unit:"litros",isActive:!0,categoryId:3,supplierId:1,cost:1.2},{name:"Refrescos",stock:200,unit:"botellas",isActive:!0,categoryId:2,supplierId:2,cost:.8},{name:"Detergente",stock:20,unit:"litros",isActive:!0,categoryId:4,supplierId:3,cost:15}],e=c.prepare(`
      INSERT INTO StockItem (name, stock, unit, isActive, categoryId, supplierId, cost)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `);t.forEach(s=>{e.run(s.name,s.stock,s.unit,s.isActive?1:0,s.categoryId,s.supplierId,s.cost)}),console.log("Stock items seeded.")}if(r("Agent")){console.log("Seed data: Adding initial agents...");const t=[{name:"Carlos",lastName:"Hern\xE1ndez",image:"",address:"Calle Principal 123, Ciudad A",phone:"555-112-3344",rfc:"CHH123456789",email:"carlos.hernandez@restaurante.com",pin:"1234",role:"manager",isActive:!0},{name:"Ana",lastName:"L\xF3pez",image:"",address:"Avenida Central 456, Ciudad B",phone:"555-223-4455",rfc:"ALO987654321",email:"ana.lopez@restaurante.com",pin:"5678",role:"cook",isActive:!0},{name:"Luis",lastName:"Mart\xEDnez",image:"",address:"Calle Secundaria 789, Ciudad C",phone:"555-334-5566",rfc:"LUM876543210",email:"luis.martinez@restaurante.com",pin:"9012",role:"waiter",isActive:!0}],e=c.prepare(`
      INSERT INTO Agent (name, lastName, image, address, phone, rfc, email, pin, role, isActive)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);t.forEach(s=>{e.run(s.name,s.lastName,s.image,s.address,s.phone,s.rfc,s.email,s.pin,s.role,s.isActive?1:0)}),console.log("Agents seeded.")}console.log("Seed completed!")},"seed"),N=W();N.use(W.json()),N.use(Q()),N.use("/authenticate",H),N.use("/items",$),N.use("/agents",M),N.use("/menu",j),N.use("/orders",v),N.use("/order-items",q),N.use("/promos",b),N.use("/categories",C),N.use("/suppliers",L),N.use("/config",U),N.use("/images",W.static("storage/images")),mt();const G=3e3;N.listen(G,()=>{console.log(process.env.RESTAURANT_NAME),console.log(`Server is running on http://localhost:${G}`)});
